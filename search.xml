<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AT24C02</title>
    <url>/2024/05/14/AT24C02/</url>
    <content><![CDATA[<h1 id="ROM-非易失性存储器"><a href="#ROM-非易失性存储器" class="headerlink" title="ROM(非易失性存储器)"></a>ROM(非易失性存储器)</h1><ol>
<li>掩模ROM（Mask ROM）</li>
</ol>
<ul>
<li>掩模ROM在制造过程中就被编程，内容由硅片设计图决定，因此不能被修改。掩模ROM成本在大规模生产时很低，但需要大量的初始投资用于开发掩模。它常用于大批量生产的消费电子产品中。</li>
</ul>
<ol start="2">
<li>可编程ROM（PROM）</li>
</ol>
<ul>
<li>PROM在制造后空白，允许用户一次性编程。编程通常通过烧写设备进行，一旦编程完成，数据就永久保存，无法更改。PROM适合于需要定制固件的应用。<span id="more"></span></li>
</ul>
<ol start="3">
<li>可擦除可编程ROM（EPROM）</li>
</ol>
<ul>
<li>EPROM可以通过紫外线光照射擦除其内容，之后可以重新编程。EPROM的窗口盖上有透明的石英玻璃，用于传输紫外线。这种类型的ROM适用于开发过程中需要多次修改代码的情况。</li>
</ul>
<ol start="4">
<li>电可擦除可编程ROM（EEPROM）</li>
</ol>
<ul>
<li>EEPROM可以在电路内电气地擦除和重新编程，不需要拆除芯片或使用紫外线。它允许按字节进行编程和擦除，提供极大的灵活性。EEPROM适用于需要频繁更新存储数据的应用，如配置设置存储。</li>
</ul>
<ol start="5">
<li>闪存（Flash Memory）</li>
</ol>
<ul>
<li>闪存是一种特殊类型的EEPROM，它支持更快的擦除和更高密度的数据存储。与EEPROM不同，闪存通常按块（而非单个字节）进行擦除和编程。因其高效性和成本效益，闪存广泛用于USB闪存驱动器、固态硬盘、手机和其他便携式电子设备。</li>
</ul>
<h1 id="存储器简化模型"><a href="#存储器简化模型" class="headerlink" title="存储器简化模型"></a>存储器简化模型</h1><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p><img src="/images/AT24C02/1.PNG" alt=" "><br>具体有线选法和重合法，不同的电路设计需要的地址线不同，一次取出的数据位数也不同</p>
<h2 id="线选法"><a href="#线选法" class="headerlink" title="线选法"></a>线选法</h2><p><img src="/images/AT24C02/2.PNG" alt=" "></p>
<h2 id="重合法"><a href="#重合法" class="headerlink" title="重合法"></a>重合法</h2><p><img src="/images/AT24C02/3.PNG" alt=" "><br>Mask ROM出厂就被设置好了，输出1的就加上二极管，否则就不加；PROM有两个二极管，第二个二极管高压容易被击穿，支持一次性烧录。<br><img src="/images/AT24C02/4.PNG" alt=" "></p>
<h1 id="AT24C02"><a href="#AT24C02" class="headerlink" title="AT24C02"></a>AT24C02</h1><p>存储介质：EEPROM<br>通讯接口：I²C总线<br>容量：256字节<br><img src="/images/AT24C02/5.PNG" alt=" "></p>
<h2 id="总线通讯"><a href="#总线通讯" class="headerlink" title="总线通讯"></a>总线通讯</h2><p>为什么需要这个协议？多个设备通讯时，如果两两通讯，将需要极为复杂的电路。如图所示：<br><img src="/images/AT24C02/6.PNG" alt=" "><br>通过总线通讯，上述电路可以大大简化：<br><img src="/images/AT24C02/7.png" alt=" "><br>既然共用数据线，就要解决怎么传输、怎么接收的问题。我们要规定一套规则完成两个设备之间的通讯。</p>
<h2 id="写数据帧"><a href="#写数据帧" class="headerlink" title="写数据帧"></a>写数据帧</h2><p>通过规定好的时序，我们依次写入设备地址、寄存器地址、数据。也就是先选中一个从设备，然后选中AT24C02的地址，再输入一个数据即可。<br><img src="/images/AT24C02/8.png" alt=" "></p>
<h2 id="读数据帧"><a href="#读数据帧" class="headerlink" title="读数据帧"></a>读数据帧</h2><p>类似的，这里是读数据帧<br><img src="/images/AT24C02/9.png" alt=" "></p>
<h2 id="时序信号"><a href="#时序信号" class="headerlink" title="时序信号"></a>时序信号</h2><p><img src="/images/AT24C02/10.png" alt=" "><br>参考来源：GTP-4生成；知乎计算机组成原理学习笔记（三）：存储器（Lucius）；B站爱上半导体</p>
]]></content>
      <categories>
        <category>元件模块</category>
      </categories>
      <tags>
        <tag>ROM</tag>
        <tag>总线通讯</tag>
        <tag>I²C</tag>
      </tags>
  </entry>
  <entry>
    <title>BCD码</title>
    <url>/2024/05/07/BCD%E7%A0%81/</url>
    <content><![CDATA[<p>Binary-Coded Decimal，二进制编码的十进制数。将每个十进制的0-9映射到四个二进制位。显然四位二进制位可以表示16种数字，映射到9个数后必然有一些位是不合法的，同时映射方案不同，得到的BCD码也不一样。</p>
<h1 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h1><p><img src="/images/BCD%E7%A0%81/1.PNG" alt=" "></p>
<span id="more"></span>
<h1 id="8421码"><a href="#8421码" class="headerlink" title="8421码"></a>8421码</h1><p>8421码与十进制数的互相转换：<br>1000 1000 &#x3D; 88<br>DEC &#x3D; BCD &#x2F; 16 * 10 +BCD % 16<br>BCD &#x3D; DEC &#x2F; 10 * 16 + BCD % 10</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>8421码</tag>
      </tags>
  </entry>
  <entry>
    <title>Canvas-Nest设置</title>
    <url>/2024/05/14/Canvas-Nest%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>想设置如下图所示的动态背景，搜了很久没找到适用自己的。通过github源头轻松解决。<br><img src="/images/Canvas-Nest%E8%AE%BE%E7%BD%AE/1.png" alt=" "></p>
<span id="more"></span>
<h1 id="源文件README"><a href="#源文件README" class="headerlink" title="源文件README"></a>源文件README</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Step 1 → Go to Hexo dir</span><br><span class="line"></span><br><span class="line">Change dir to Hexo directory. There must be scaffolds, source, themes and other directories:</span><br><span class="line"></span><br><span class="line">$ cd hexo</span><br><span class="line">$ ls</span><br><span class="line">scaffolds  source  themes  _config.yml  package.json</span><br><span class="line"></span><br><span class="line">Step 2 → Create footer.swig</span><br><span class="line"></span><br><span class="line">Create a file named footer.swig in hexo/source/_data directory (create _data directory if it does not exist).</span><br><span class="line"></span><br><span class="line">Edit this file and add the following content:</span><br><span class="line"></span><br><span class="line">&lt;script color=&quot;0,0,255&quot; opacity=&quot;0.5&quot; zIndex=&quot;-1&quot; count=&quot;99&quot; src=&quot;https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">You can customize these options.</span><br><span class="line">Step 3 → Set it up</span><br><span class="line"></span><br><span class="line">In the NexT _config.yml, uncomment footer under the custom_file_path section.</span><br><span class="line"></span><br><span class="line"># Define custom file paths.</span><br><span class="line"># Create your custom files in site directory `source/_data` and uncomment needed files below.</span><br><span class="line">custom_file_path:</span><br><span class="line">  #head: source/_data/head.swig</span><br><span class="line">  #header: source/_data/header.swig</span><br><span class="line">  #sidebar: source/_data/sidebar.swig</span><br><span class="line">  #postMeta: source/_data/post-meta.swig</span><br><span class="line">  #postBodyEnd: source/_data/post-body-end.swig</span><br><span class="line">  footer: source/_data/footer.swig</span><br><span class="line">  #bodyEnd: source/_data/body-end.swig</span><br><span class="line">  #variable: source/_data/variables.styl</span><br><span class="line">  #mixin: source/_data/mixins.styl</span><br><span class="line">  #style: source/_data/styles.styl</span><br></pre></td></tr></table></figure>
<p> 参考来源：<a href="https://github.com/theme-next/theme-next-canvas-nest">https://github.com/theme-next/theme-next-canvas-nest</a></p>
]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>动态背景</tag>
      </tags>
  </entry>
  <entry>
    <title>DS1302</title>
    <url>/2024/05/07/DS1302/</url>
    <content><![CDATA[<h1 id="模块功能"><a href="#模块功能" class="headerlink" title="模块功能"></a>模块功能</h1><p>提供年、月、日、时、分、秒的计时。</p>
<h1 id="引脚定义"><a href="#引脚定义" class="headerlink" title="引脚定义"></a>引脚定义</h1><p><img src="/images/DS1302/1.png" alt=" "></p>
<span id="more"></span>
<h1 id="应用电路"><a href="#应用电路" class="headerlink" title="应用电路"></a>应用电路</h1><p>VCC1、2：分别是备用电源和主电源，备用电源提供非易失性存储功能。<br>X1和X2表示晶振：32.768KHZ，用于提供时钟信号，晶振的核心是石英晶体，通过改变其形状、尺寸、切割方式而产生不同的频率。<br>CE：Chip Enable，芯片使能。<br>I&#x2F;O：数据输入输出<br>SCLK：串行时钟<br><img src="/images/DS1302/2.png" alt=" "></p>
<h1 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h1><p>晶振提供时钟信号，RAM存储时间信息并提供通用寄存器。通过CE、I&#x2F;O、SCLK接口与RAM交互。<br><img src="/images/DS1302/3.png" alt=" "></p>
<h1 id="在哪儿、读-写？"><a href="#在哪儿、读-写？" class="headerlink" title="在哪儿、读&#x2F;写？"></a>在哪儿、读&#x2F;写？</h1><p>一个字节中，最低位控制读写、第6位选择RAM or CK（上面加一横表示低电平有效）<br><img src="/images/DS1302/4.png" alt=" "><br>WP表示Write Protect，置1时不可写入。<br>TCS是备用电池的设置。<br><img src="/images/DS1302/5.png" alt=" "></p>
<h1 id="时序定义"><a href="#时序定义" class="headerlink" title="时序定义"></a>时序定义</h1><p>CE全程置1；<br>I&#x2F;O上升沿写入单片机、单片机中的数据每个下降沿到I&#x2F;O口处。<br>第一个字节确认读出或写入操作、确认地址（在哪儿操作）。<br>第二个字节操作读出数据或者继续写入数据。<br><img src="/images/DS1302/5.png" alt=" "><br>通过for循环搭配SCLK信号，串行读入或者写出数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DS1302_WriteByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Command, <span class="type">unsigned</span> <span class="type">char</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">        DS1302_CE = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                DS1302_IO = Command &amp; (<span class="number">0x01</span>&lt;&lt;i);</span><br><span class="line">                DS1302_SCLK = <span class="number">1</span>;</span><br><span class="line">                DS1302_SCLK = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                DS1302_IO = Data &amp; (<span class="number">0x01</span>&lt;&lt;i);</span><br><span class="line">                DS1302_SCLK = <span class="number">1</span>;</span><br><span class="line">                DS1302_SCLK = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        DS1302_CE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">DS1302_ReadByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Command)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> i, Data = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">        DS1302_CE = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                DS1302_IO = Command &amp; (<span class="number">0x01</span>&lt;&lt;i);</span><br><span class="line">                DS1302_SCLK = <span class="number">0</span>;</span><br><span class="line">                DS1302_SCLK = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">8</span> ;i++)</span><br><span class="line">        &#123;</span><br><span class="line">                DS1302_SCLK = <span class="number">1</span>;</span><br><span class="line">                DS1302_SCLK = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (DS1302_IO) &#123;Data |= (<span class="number">0x01</span>&lt;&lt;i);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        DS1302_CE = <span class="number">0</span>;</span><br><span class="line">        DS1302_IO = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考来源：DS1302 Trickle-Charge Timekeeping Chip; B站江协科技</p>
]]></content>
      <categories>
        <category>元件模块</category>
      </categories>
      <tags>
        <tag>时钟电路</tag>
        <tag>实时时钟</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>Virtual PLC in Industrial Edge Platform</title>
    <url>/2024/05/29/Literature2/</url>
    <content><![CDATA[<h1 id="标题（Title）"><a href="#标题（Title）" class="headerlink" title="标题（Title）"></a>标题（Title）</h1><p>Virtual PLC in Industrial Edge Platform: Performance Evaluation of Supervision and Control Communication<br>本文探讨了虚拟PLC在工业边缘平台的性能，这个性能关注的主要是监督和控制通信。<br>IEEE TRANSACTIONS ON INSTRUMENTATION AND MEASUREMENT, VOL. 73, 2024</p>
<h1 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h1><p>边缘计算可以减少延时，PLC设备和边缘计算结合可以更好的实现自动控制。为了追求更高的可扩展性和可维护性，容器化的虚拟PLC成为一种方案。但vPLC的短板就在于其通信延时可能增加。本文就在研究vPLC在机器对机器（M2M）场景中与其他机器、控制器、监督系统和数据采集系统交换数据时的性能。结果指出，vPLC可以同样达到3ms的延时，但是由于其IP栈的实现，可能会出现50ms的随机延时。</p>
<span id="more"></span>
<h1 id="背景（Background）"><a href="#背景（Background）" class="headerlink" title="背景（Background）"></a>背景（Background）</h1><p>虚拟PLC（vPLC）的优势：<br>最新的方法提出了虚拟PLC（vPLC），即PLC固件的容器化版本。vPLC可以在任何支持容器的平台上运行，确保易于维护、轻量虚拟化，并完全独立于硬件和操作系统。此外，基于容器的自动化方法允许微服务架构，提供可扩展性、可观测性、可追溯性和可核查性等新特性。工业设备可以（独立于硬件）运行所需的服务，维护和更新由中心化管理，确保系统的安全性和完整性。</p>
<p>工业上无法接受抖动和高延迟。因此对vPLC的性能评估至关重要。</p>
<p>本项目的目标是提供一种方法、实验程序和一套指标，用于评估PLC和vPLC的通信和数据交换性能。由于PLC位于自动化栈的中心，它们有两种数据交换方式：一是与其他机器、监督控制和数据采集（SCADA）系统连接，二是与传感器和执行器连接以执行控制动作。虽然传统PLC在这两个方面已有充分研究，但对容器化vPLC的研究相对缺乏。</p>
<p>重点评估PLC之间或PLC与SCADA之间的机器对机器（M2M）数据交换性能。主要贡献包括：</p>
<ol>
<li>定义一种方法，从数据流角度比较PLC和vPLC的性能。</li>
<li>定义一个实验设置及其相关实验程序。</li>
<li>定义用于比较性能的指标。</li>
<li>将所提出的方法应用于实际工业用例，展示其对系统建模、得出结论及改进实时行为的实用性。</li>
</ol>
<p>传统架构和虚拟化之后的架构<br><img src="/images/Literature2/1.PNG" alt=" "><br>传统SCADA集收集、监控、分析数据为一体。运用虚拟化技术，不仅仅PLC可以虚拟化，sensors和SCADA也可以。</p>
<p>影响虚拟化性能的三因素</p>
<ol>
<li>virtualization technique</li>
<li>operating system</li>
<li>hypervisor</li>
</ol>
<p>主要的虚拟化技术有：</p>
<ul>
<li>完全虚拟化：提供高水平的隔离，允许在单台物理机器上同时运行多个操作系统。</li>
<li>容器化（轻量虚拟化）：容器提供了一种轻量级虚拟化形式，共享主机操作系统内核。</li>
</ul>
<h1 id="主要内容（Main-Content）"><a href="#主要内容（Main-Content）" class="headerlink" title="主要内容（Main Content）"></a>主要内容（Main Content）</h1><p>研究目标</p>
<ol>
<li>方法论设计：设计一种评估现有架构性能的方法，特别关注在监督级别（M2M、C2C和SCADA）上的通信性能。</li>
<li>实验设置：定义实验设置和程序，用于实际工业用例的测试。</li>
<li>性能指标：定义性能指标，用于比较PLC和vPLC的数据交换性能。</li>
<li>实际应用：通过实际用例展示所提出方法的有效性，特别是比较vPLC和真实PLC在机器对机器数据交换中的性能</li>
</ol>
<p>方法概述<br>测试设置：</p>
<ol>
<li>识别通信伙伴：在测试架构中，首先识别两个通信伙伴，分别称为客户端PLC（Client PLC，C）和边缘PLC（Edge PLC，E），它们通过M2M（机器对机器）协议连接。</li>
<li>网络访问：识别用于数据交换的物理网络，并使用网络访问点（T）捕获和分析所有相关数据包，以评估网络延迟和通信栈延迟。</li>
<li>事务类型：确定要评估的事务类型，例如“请求与响应”事务类型，这在许多监督协议中非常常见。</li>
<li>时间戳：对每个事务相关的事件在C、E和T上进行时间戳记录，并引入适当的请求随机化，以确保事务之间没有时间关联。<br><img src="/images/Literature2/2.PNG" alt=" "><br>性能指标<br>定义了若干性能指标，用于评估“请求与响应”类型事务中的延迟。这些指标包括：<br>LCC：请求-响应往返时间。<br>LTT：从请求发送到响应接收的通信栈延迟。<br>LEC：从请求生成到接收到请求的延迟。<br>LCE：从响应生成到读取响应的延迟。<br>LTC：请求从C传输到总线的延迟。<br>LET：请求从网络传输到E的延迟，包括E的通信栈。<br>LTE：响应从E传输到网络的延迟。<br>LCT：响应从网络传输到C的延迟，包括C的通信栈。<br>对于“发布与确认”类型事务，指标相同，而对于“发布无确认”类型事务，只需使用相关方向上的子集指标。</li>
</ol>
<p>同步<br>为了确保分布式测量系统中的时间戳一致性，本文采用网络时间协议（NTP）进行设备同步，通过交换数据包确定客户端与服务器之间的时钟偏移和网络延迟，并校正客户端时钟。</p>
<p>实验设置与用例<br>在实验设置中，使用以太网作为网络，利用以太网Tap设备（Profitap C1AP-100）复制所有以太网流量并将其转发到嵌入式系统（Siemens IOT2050）进行时间戳记录和数据存储。<br>用例中使用的设备包括：</p>
<ol>
<li>PLC S7-1512C-1 PN：作为真实PLC的代表，具有快速CPU和实时协议支持。</li>
<li>CPU1582V（vPLC）：在Simatic IPC227E工业PC和桌面PC上运行，作为虚拟PLC的代表。<br>实验矩阵中包含各种设备组合，以全面评估不同环境下的性能。<br><img src="/images/Literature2/3.PNG" alt=" "><br>协议和数据验证<br>用例中使用S7comm协议进行M2M通信，评估请求和响应事务中的延迟。通过分析网络数据包，识别和过滤掉偶发的地址解析协议（ARP）活动，以确保评估的准确性。</li>
</ol>
<p>发现：</p>
<ul>
<li>当两个通信伙伴都是真实PLC时，事务非常快，延迟变动极小。</li>
<li>当一个通信伙伴为vPLC时，延迟变动较大，主要是由于vPLC的IP栈实现采用100ms的轮询周期。</li>
</ul>
<p>实验结果</p>
<ul>
<li>实验结果显示，vPLC的响应时间分布存在两个100ms周期，一个用于C，一个用于E。</li>
<li>平均往返时间（LCC）在真实PLC之间约为3.3ms，而vPLC之间则接近100ms。</li>
</ul>
<h1 id="评价和感想（Evaluation-and-Reflections）"><a href="#评价和感想（Evaluation-and-Reflections）" class="headerlink" title="评价和感想（Evaluation and Reflections）"></a>评价和感想（Evaluation and Reflections）</h1><ul>
<li>Docker技术似乎很火，可以了解一下。并自己实现一个vPLC</li>
</ul>
<h1 id="未来研究方向（Future-Research-Directions）"><a href="#未来研究方向（Future-Research-Directions）" class="headerlink" title="未来研究方向（Future Research Directions）"></a>未来研究方向（Future Research Directions）</h1><ol>
<li>实时通信评估：<ul>
<li>未来的研究将重点评估vPLC在与传感器和执行器的实时通信中的性能。这将涉及更精细的时间测量设备，如直接1-PPS同步信号和GPS接收器。</li>
</ul>
</li>
<li>硬件和成本考虑：<ul>
<li>考虑到实时测量可能需要额外的硬件和成本，未来的研究将探索更经济高效的解决方案。</li>
</ul>
</li>
<li>虚拟组件的发展：<ul>
<li>随着虚拟组件（如vPLC）的发展，基于本文描述的测量和测试程序，虚拟组件的性能可以快速改进。设计、测试和重新设计的循环可以显著提升虚拟组件的可靠性和性能。</li>
</ul>
</li>
</ol>
<h1 id="参考文献（References）"><a href="#参考文献（References）" class="headerlink" title="参考文献（References）"></a>参考文献（References）</h1><p><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=10449455">https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=10449455</a><br>Gaffurini, M., Bellagente, P., Depari, A., Flammini, A., Sisinni, E., &amp; Ferrari, P. (2024). Virtual PLC in industrial edge platform: performance evaluation of supervision and control communication. IEEE Transactions on Instrumentation and Measurement.</p>
]]></content>
      <categories>
        <category>文献调研</category>
      </categories>
      <tags>
        <tag>Container based virtualization</tag>
        <tag>controller to controller (C2C)</tag>
        <tag>machine-to-machine (M2M)</tag>
        <tag>programmable logic controller (PLC)</tag>
        <tag>supervisory control</tag>
        <tag>data acquisition (SCADA)</tag>
      </tags>
  </entry>
  <entry>
    <title>YOLOv10 Real-Time End-to-End Object Detection</title>
    <url>/2024/06/02/Literature3/</url>
    <content><![CDATA[<h1 id="标题（Title）"><a href="#标题（Title）" class="headerlink" title="标题（Title）"></a>标题（Title）</h1><p>YOLOv10: Real-Time End-to-End Object Detection<br>目标检测经典模型，YOLO系列，还没用过，试一次。<br>23 May 2024</p>
<h1 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h1><p>YOLOs在实施目标检测的应用方向占据主导地位，其很好的平衡了计算效率和准确率。然而YOLO依然存在问题，YOLO算法依赖于非极大值抑制（NMS）进行后处理，这对端到端部署和推理延迟产生负面影响。此外，YOLO的各个组件设计缺乏全面检查，导致计算冗余和模型能力受限。为了解决上述问题，本文提出一致双重分配策略（Consistent Dual Assignments）和整体效率-准确性驱动的模型设计策略。大量实验验证本策略达到了state-of-the-art的效率以及表现。</p>
<span id="more"></span>
<h1 id="主要内容（Main-Content）"><a href="#主要内容（Main-Content）" class="headerlink" title="主要内容（Main Content）"></a>主要内容（Main Content）</h1><h2 id="现有技术的缺陷"><a href="#现有技术的缺陷" class="headerlink" title="现有技术的缺陷"></a>现有技术的缺陷</h2><ol>
<li>依赖于非极大值抑制（NMS）</li>
</ol>
<ul>
<li>问题描述：YOLO算法依赖于非极大值抑制（NMS）进行后处理，以消除重叠的检测框。NMS是一种后处理技术，用于在多个重叠的检测框中保留得分最高的一个，消除其他重叠框。</li>
<li>缺陷：NMS的计算复杂度较高，并且在端到端的实时检测任务中增加了额外的计算开销和延迟。此外，NMS处理步骤需要将模型输出与后处理分离，这使得整个模型不完全端到端。</li>
</ul>
<ol start="2">
<li>组件设计缺乏系统性检查</li>
</ol>
<ul>
<li>问题描述：YOLO系列算法的各个组件（如检测头、特征提取网络等）的设计和优化常常是独立进行的，缺乏全局视角的系统性检查和优化。</li>
<li>缺陷：这种缺乏系统性检查的设计方式导致了计算冗余和模型能力受限。例如，某些组件可能存在计算资源浪费，或设计上未能充分发挥其潜力，整体效率和性能受到影响。</li>
</ul>
<ol start="3">
<li>计算冗余</li>
</ol>
<ul>
<li>问题描述：YOLO算法的某些设计存在计算冗余，未能充分利用计算资源。</li>
<li>缺陷：计算冗余意味着在模型的推理过程中，有些计算步骤是多余的或可以简化的。这不仅增加了模型的计算量，也增加了推理时间，降低了模型的整体效率。</li>
</ul>
<ol start="4">
<li>模型能力受限</li>
</ol>
<ul>
<li>问题描述：由于设计上的局限性，现有YOLO模型在处理复杂场景和小目标时表现不够理想。</li>
<li>缺陷：模型能力受限意味着在实际应用中，YOLO模型可能无法准确检测复杂背景中的小目标，影响了模型的实用性和可靠性。</li>
</ul>
<h2 id="核心解决思路"><a href="#核心解决思路" class="headerlink" title="核心解决思路"></a>核心解决思路</h2><ol>
<li>一致双重分配策略（Consistent Dual Assignments）<br>1.1 无NMS训练</li>
</ol>
<ul>
<li>背景：传统YOLO模型依赖非极大值抑制（NMS）来消除多余的重叠检测框。这增加了计算开销，并在端到端推理过程中引入延迟。</li>
<li>解决方案：YOLOv10提出了一种无NMS的训练策略，通过结合一对多和一对一匹配方法来实现高效的目标检测。<ul>
<li>一对多匹配：在训练阶段，模型将一个预测框与多个真实框匹配。这有助于提高模型对目标的召回率（recall），即减少漏检。</li>
<li>一对一匹配：在推理阶段，模型仅使用一对一匹配来确保每个真实框只对应一个预测框，从而避免重复检测。<br>1.2 一致匹配度量</li>
</ul>
</li>
<li>背景：传统的一对多和一对一匹配方法在优化目标上可能存在差异，导致模型在训练和推理时表现不一致。</li>
<li>解决方案：YOLOv10采用一致的匹配度量方法，使得一对多匹配和一对一匹配在优化方向上保持一致。这减少了监督差距，确保训练和推理的优化目标一致，提高了模型性能。</li>
</ul>
<ol start="2">
<li>整体效率-准确性驱动的模型设计策略<br>2.1 轻量级分类头</li>
</ol>
<ul>
<li>背景：YOLO模型的分类头通常较为复杂，增加了计算量和模型参数量。</li>
<li>解决方案：YOLOv10引入轻量级分类头，通过简化分类头的结构来减少计算开销，同时保持分类性能。这样既能降低计算负担，又能保持高效的分类能力。<br>2.2 空间-通道解耦下采样</li>
<li>背景：传统的下采样操作（如卷积）同时处理空间和通道信息，可能导致信息丢失和计算冗余。</li>
<li>解决方案：YOLOv10提出了空间-通道解耦下采样方法，将空间下采样和通道变换解耦开来，分别进行处理。这种方法能够更有效地保留和处理信息，提高模型的计算效率和检测性能。<br>2.3 基于内在秩的模块设计</li>
<li>背景：传统YOLO模型在不同阶段的特征图处理上可能存在冗余，未充分利用计算资源。</li>
<li>解决方案：YOLOv10基于内在秩分析各个阶段的冗余，提出了紧凑的反转块设计。这种设计方法有助于减少冗余计算，提高模型的整体效率。<br><img src="/images/Literature3/1.PNG" alt=" "><br><img src="/images/Literature3/2.PNG" alt=" "></li>
</ul>
<h2 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h2><ol>
<li>基准数据集<br>作者在多个标准目标检测基准数据集上评估了YOLOv10，包括：</li>
</ol>
<ul>
<li>COCO（Common Objects in Context）：一个广泛使用的目标检测数据集，包含80个对象类别。</li>
<li>VOC（PASCAL Visual Object Classes）：另一个著名的数据集，包含20个对象类别。</li>
</ul>
<ol start="2">
<li>模型变体<br>YOLOv10在不同配置下进行了测试，分别标记为n、s、m、b、l和x，代表纳米（nano）、小（small）、中（medium）、基础（base）、大（large）和超大（extra-large）模型。这些配置在速度和准确性之间取得了平衡。</li>
<li>评估指标<br>主要评估指标包括：</li>
</ol>
<ul>
<li>mAP（mean Average Precision）：目标检测准确性的标准指标。</li>
<li>推理速度：每张图像的推理时间（以毫秒为单位），表示模型的效率。</li>
<li>模型大小：反映参数数量和计算复杂度。</li>
</ul>
<ol start="4">
<li>性能比较<br>YOLOv10与几个最先进的模型进行了比较，包括以前的YOLO版本和其他领先的目标检测模型如Faster R-CNN、SSD和EfficientDet。结果显示：</li>
</ol>
<ul>
<li>更高的mAP：YOLOv10在mAP得分上优于以前的版本，表明其准确性更高。</li>
<li>更快的推理速度：该模型保持了实时推理能力，这对需要低延迟的应用至关重要。</li>
<li>更小的模型大小：尽管性能提高，YOLOv10模型设计紧凑，适合在资源受限的设备上部署。</li>
</ul>
<ol start="5">
<li>消融研究<br>论文包括详细的消融研究，以单独分析YOLOv10的不同组件的贡献。这些研究考察了：</li>
</ol>
<ul>
<li>一致双重分配策略的效果：展示了提出的双重分配策略对模型性能的影响。</li>
<li>效率驱动的设计选择的影响：评估了轻量级分类头和空间-通道解耦下采样等架构变化对整体性能的贡献。</li>
</ul>
<ol start="6">
<li>定性结果<br>作者提供了定性示例，展示了YOLOv10在复杂条件下检测目标的能力，例如拥挤场景和小目标。这些视觉结果突出了模型的鲁棒性和泛化能力。<br><img src="/images/Literature3/3.PNG" alt=" "></li>
</ol>
<h1 id="评价和感想（Evaluation-and-Reflections）"><a href="#评价和感想（Evaluation-and-Reflections）" class="headerlink" title="评价和感想（Evaluation and Reflections）"></a>评价和感想（Evaluation and Reflections）</h1><p>经典的模型优化思路，详实的实验验证。<br>未来研究方向（Future Research Directions）</p>
<ul>
<li>主要是直接应用这些模型吧，想要自己做改进并不容易，可能对于具体情境可以做相对应的微创新。</li>
</ul>
<h1 id="参考文献（References）"><a href="#参考文献（References）" class="headerlink" title="参考文献（References）"></a>参考文献（References）</h1><p>Wang, A., Chen, H., Liu, L., Chen, K., Lin, Z., Han, J., &amp; Ding, G. (2024). YOLOv10: Real-Time End-to-End Object Detection. arXiv preprint arXiv:2405.14458.<br><a href="https://arxiv.org/pdf/2405.14458">https://arxiv.org/pdf/2405.14458</a></p>
]]></content>
      <categories>
        <category>文献调研</category>
      </categories>
      <tags>
        <tag>YOLO</tag>
        <tag>实时目标监测</tag>
      </tags>
  </entry>
  <entry>
    <title>A Cyber-Physical Systems architecture for Industry 4.0-based manufacturing</title>
    <url>/2024/06/02/Literature4/</url>
    <content><![CDATA[<h1 id="标题（Title）"><a href="#标题（Title）" class="headerlink" title="标题（Title）"></a>标题（Title）</h1><p>A Cyber-Physical Systems architecture for Industry 4.0-based manufacturing systems<br>本文研究工业4.0背景下制造系统的信息物理系统架构<br>Article  in  Manufacturing Letters · December 2014 </p>
<h1 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h1><p>本文主要讨论了如何通过部署网络物理系统（CPS）来实现工业4.0，工业4.0的核心在于通过网络物理系统（CPS）将物理世界和计算空间紧密结合，以实现更高效、更协作和更具弹性的制造系统。CPS利用传感器、大数据和先进的分析方法，实时监控和管理制造过程中的各个方面。在这一早期发展阶段，迫切需要对CPS进行明确定义。本文提出了一个统一的五级架构，作为CPS实施的指导方针。</p>
<span id="more"></span>
<h1 id="背景（Background）"><a href="#背景（Background）" class="headerlink" title="背景（Background）"></a>背景（Background）</h1><p>网络物理系统（CPS）被定义为管理物理资产和计算能力之间互联系统的变革性技术。随着传感器、数据采集系统和计算机网络的普及，越来越多的工厂开始实施高科技方法。不断增加的传感器和联网机器的使用导致了大量数据的生成，称为大数据。在这种环境下，CPS可以进一步发展，以管理大数据并利用机器的互联性，实现智能、弹性和自适应的目标。<br><img src="/images/Literature4/1.PNG" alt=" "></p>
<h1 id="主要内容（Main-Content）"><a href="#主要内容（Main-Content）" class="headerlink" title="主要内容（Main Content）"></a>主要内容（Main Content）</h1><h2 id="CPS-5C架构部分总结"><a href="#CPS-5C架构部分总结" class="headerlink" title="CPS 5C架构部分总结"></a>CPS 5C架构部分总结</h2><p>本文提出的五级CPS结构，即5C架构，提供了一个逐步开发和部署CPS用于制造应用的指导方针。一般来说，CPS包括两个主要功能组件：<br>（1）先进的连接性，确保从物理世界到网络空间的实时数据采集和信息反馈；<br>（2）智能数据管理、分析和计算能力，构建网络空间。<br>然而，这种要求过于抽象，不足以用于具体的实施。相反，本文提出的5C架构通过顺序工作流程方式，明确定义了如何从初始数据采集、到分析、再到最终价值创造构建CPS。具体的5C架构如下：<br><img src="/images/Literature4/2.PNG" alt=" "></p>
<ol>
<li>智能连接（Smart Connection）</li>
</ol>
<ul>
<li>获取机器及其组件的准确可靠数据是开发CPS的第一步。这些数据可能直接通过传感器测量，或从控制器或企业制造系统（如ERP、MES、SCM和CMM）中获取。需要考虑的两个重要因素是：管理数据采集过程并将数据传输到中央服务器的无缝方法，以及选择合适的传感器（类型和规格）。</li>
</ul>
<ol start="2">
<li>数据到信息的转换（Data-to-Information Conversion）</li>
</ol>
<ul>
<li>需要从数据中推导出有意义的信息。目前有多种工具和方法可用于数据到信息的转换，特别是用于预测和健康管理应用的算法，例如计算健康值和剩余使用寿命等，使机器具备自我感知能力。</li>
</ul>
<ol start="3">
<li>网络（Cyber）</li>
</ol>
<ul>
<li>在该层级，信息从每台联网的机器推送到中央信息中心，形成机器网络。通过特定的分析方法，从大量信息中提取出更好的洞察力，支持机器之间的自我比较和未来行为预测。</li>
</ul>
<ol start="4">
<li>认知（Cognition）</li>
</ol>
<ul>
<li>在该层级，CPS的实施会对监控系统生成全面的知识，帮助专家用户进行正确决策。由于获得了比较信息和单个机器状态的信息，优化维护过程的任务优先级可以被确定。</li>
</ul>
<ol start="5">
<li>配置（Configuration）</li>
</ol>
<ul>
<li>这是从网络空间到物理空间的反馈控制，使机器能够自我配置和自适应。该层级作为弹性控制系统（RCS），应用认知层级所做的纠正和预防决策于监控系统。<br><img src="/images/Literature4/3.PNG" alt=" "></li>
</ul>
<h2 id="基于PHM的CPS系统设计部分总结"><a href="#基于PHM的CPS系统设计部分总结" class="headerlink" title="基于PHM的CPS系统设计部分总结"></a>基于PHM的CPS系统设计部分总结</h2><p>网络层级的PHM（预测性健康管理）的极大优势在于，通过机器-网络接口（CPI）在网络层级实现机器健康分析的互联互通，这在概念上类似于社交网络。一旦网络层级的基础设施到位，机器可以注册到网络中并通过网络接口交换信息。在这一点上，需要建立一个算法来跟踪机器状态的变化，从历史信息中推断出额外的知识，进行点对点比较，并将输出传递到下一个层级。为了执行这些操作并生成适当的结果，需要开发新的方法。本文介绍了在网络层级执行分析的“时间机器”，包括以下三个并行部分：</p>
<ol>
<li>快照收集</li>
</ol>
<ul>
<li>信息不断从机器推送到网络空间。快照收集的作用是管理传入的数据并以高效的方式存储信息。基本上，为了减少所需的磁盘空间和处理能力，只记录机器性能、使用历史和维护的快照，而不是整个时间序列。只有在监控机器状态发生显著变化时才会拍摄这些快照。此变化可以定义为机器健康值的剧烈变化、维护行动或工作状态的变化。在机器生命周期中，这些快照将累积起来，用于构建特定资产的时间机器历史记录。此活动的时间机器记录将用于资产之间的点对点比较。一旦资产故障或更换，其相关时间机器记录将从活动状态变为历史状态，用于相似性识别和合成参考。</li>
</ul>
<ol start="2">
<li>相似性识别</li>
</ol>
<ul>
<li>在网络层级，由于可以从多台机器获得信息，在较短时间内捕获特定故障模式的可能性较高。因此，相似性识别部分必须回顾历史时间机器记录，计算当前机器行为与前期资产利用和健康状况的相似性。在此阶段，可以使用不同的算法进行模式匹配，例如匹配矩阵、轨迹相似性方法或各种随机方法。一旦模式匹配，监控系统的未来行为可以更准确地预测。</li>
</ul>
<ol start="3">
<li>合成优化未来步骤</li>
</ol>
<ul>
<li>预测资产的剩余使用寿命有助于在制造工厂中维持即时维护策略。此外，寿命预测与历史时间机器记录相结合，可以根据当前健康状况提高资产利用效率。类似资产在不同健康阶段的历史利用模式提供了所需信息，用于模拟目标资产可能的未来利用场景及其结果。在这些场景中，可以为目标资产实施最有效且最具生产力的利用模式。<br><img src="/images/Literature4/4.png" alt=" "><br><img src="/images/Literature4/5.png" alt=" "><br>在现代工厂中实施网络物理系统（CPS）可以带来多方面的优势，这些优势可以分为三个阶段：组件、机器和生产系统。具体如下：</li>
</ul>
<ol>
<li>组件阶段</li>
</ol>
<ul>
<li>一旦将关键组件的传感数据转换为信息，每个组件的数字孪生体将负责捕获时间机器记录并综合未来步骤，以实现自我感知和自我预测。</li>
</ul>
<ol start="2">
<li>机器阶段</li>
</ol>
<ul>
<li>更高级的机器数据（如控制器参数）将被聚合到组件信息中，以监控状态并生成每台机器的数字孪生体。这些机器的数字孪生体在CPS中提供了额外的自我比较能力。</li>
</ul>
<ol start="3">
<li>生产系统阶段</li>
</ol>
<ul>
<li>从组件和机器级信息中聚合的知识为工厂提供了自我配置和自我维护能力。这种知识水平不仅保证了无忧和接近零停机时间的生产，还为工厂管理提供了优化的生产计划和库存管理方案。</li>
</ul>
<h1 id="评价和感想（Evaluation-and-Reflections）"><a href="#评价和感想（Evaluation-and-Reflections）" class="headerlink" title="评价和感想（Evaluation and Reflections）"></a>评价和感想（Evaluation and Reflections）</h1><p>物理信息系统是实现工业4.0的核心，整个工厂就像一个智能生物体。就像人类的身体有无数的感官系统（传感器）来收集信息，这个智能生物体的各个机器通过网络空间互联，形成一个紧密合作的系统。数据被汇聚和处理，就像人体中的神经系统和大脑进行分析和决策。通过大数据处理技术，这个智能生物体能够进行自我体检，提前发现和解决潜在的问题，从而保持最佳状态和高效运行。</p>
<h1 id="未来研究方向（Future-Research-Directions）"><a href="#未来研究方向（Future-Research-Directions）" class="headerlink" title="未来研究方向（Future Research Directions）"></a>未来研究方向（Future Research Directions）</h1><p>这篇文献不能实践，只是了解下CPS在I4.0下的应用。</p>
<h1 id="参考文献（References）"><a href="#参考文献（References）" class="headerlink" title="参考文献（References）"></a>参考文献（References）</h1><p><a href="https://www.researchgate.net/publication/269709304">https://www.researchgate.net/publication/269709304</a><br>Lee, J., Bagheri, B., &amp; Kao, H. A. (2015). A cyber-physical systems architecture for industry 4.0-based manufacturing systems. Manufacturing letters, 3, 18-23.</p>
]]></content>
      <categories>
        <category>文献调研</category>
      </categories>
      <tags>
        <tag>Cyber-Physical System</tag>
        <tag>Industry 4.0</tag>
        <tag>Health management and prognostics</tag>
        <tag>Time machine</tag>
      </tags>
  </entry>
  <entry>
    <title>LLM4PLC Harnessing Large Language Models for Verifiable Programming of PLCs in Industrial Control Systems</title>
    <url>/2024/06/03/Literature5/</url>
    <content><![CDATA[<h1 id="标题（Title）"><a href="#标题（Title）" class="headerlink" title="标题（Title）"></a>标题（Title）</h1><p>LLM4PLC Harnessing Large Language Models for Verifiable Programming of PLCs in Industrial Control Systems<br>利用大模型为PLC自动生成代码，PLC用于工业控制。<br>arXiv:2401.05443v1 [cs.SE] 8 Jan 2024</p>
<h1 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h1><p>大语言模型在自动化生成代码方面已经起到重要作用，但是其应用在自动控制领域仍然面临挑战。类似用于PLC的代码面对如下挑战。</p>
<ol>
<li>训练样本少</li>
<li>对代码的可靠性要求极高，这些代码会直接作用于物理世界，稍有偏差就可能造成重大损失。（仿真是解决问题的一个思路，如果PLC自动生成代码，然后先在仿真环境跑通，再部署到产线上，这应该是这个方向的进一步创新。而且仿真的结果可以直接反馈给LLM，方便其进一步迭代，这将比本文描述的方案更为高效。）<br>本文提出了LLM4PLC，用于自动化生成PLC代码，为了解决上述的问题，引入了grammar checkers, compilers and SMV verifiers确保生成代码的可靠性。对大模型进行微调和针对性的提示词工程。<br>最后本文生成的代码在MFTB平台上进行了测试，证明了该方法对PLC代码有较大提升。<span id="more"></span></li>
</ol>
<h1 id="背景（Background）"><a href="#背景（Background）" class="headerlink" title="背景（Background）"></a>背景（Background）</h1><p>PLC是特定领域的实时计算机，运行专门的程序，并采用IEC 61131-3标准下的五种编程范式之一。其中，结构化文本（ST）由于其语法和结构与传统编程语言相似，适合使用最先进的技术进行自动代码生成。<br>然而，开发可靠且安全的PLC软件非常复杂且耗时。为了提高工程效率，本文提出了LLM4PLC框架，该框架通过使用大型语言模型（LLM）自动生成PLC代码，并结合用户反馈和外部验证工具，确保代码的安全性和有效性。<br><img src="/images/Literature5/1.PNG" alt=" "></p>
<h1 id="主要内容（Main-Content）"><a href="#主要内容（Main-Content）" class="headerlink" title="主要内容（Main Content）"></a>主要内容（Main Content）</h1><p>本文采用的方法基于现有的PLC软件工程、形式验证方法以及最先进的LLM提示和参数高效微调（PEFT）技术，包括低秩适应（LoRAs）。本节提供了每个领域的必要背景知识，并介绍了我们在所提出方法中采用的设计选择动机。<br><img src="/images/Literature5/2.PNG" alt=" "></p>
<h3 id="大型语言模型（LLM）"><a href="#大型语言模型（LLM）" class="headerlink" title="大型语言模型（LLM）"></a>大型语言模型（LLM）</h3><p>大型语言模型（LLM）利用Transformer架构中的注意力机制来建模不断增加长度的序列。Transformer模型的核心是自注意力机制，它计算序列中每对标记的注意力分数，从而允许在序列内长距离之间的依赖关系和关系。所有主要的LLM都使用下一个标记预测（NTP）方案一次生成一个标记。</p>
<h3 id="模型驱动设计（MBD）"><a href="#模型驱动设计（MBD）" class="headerlink" title="模型驱动设计（MBD）"></a>模型驱动设计（MBD）</h3><p>模型驱动设计（MBD）是一个工程范式，它利用数学和图形建模来促进复杂系统的分析、实现和模拟。通过使用有限状态机（FSM）显式规划来优化PLC扫描周期，每个FSM状态负责单一操作，使执行过程可预测且易于调试。在自然语言规范的MBD提示中，我们约束LLM遵循FSM设计以解决方案。</p>
<h3 id="语法检查器和形式验证"><a href="#语法检查器和形式验证" class="headerlink" title="语法检查器和形式验证"></a>语法检查器和形式验证</h3><ul>
<li>语法检查器：在将候选代码转换为可运行程序的第一步是检查其是否符合编程语言的标准。如果发现任何错误，这些错误会反馈到我们的管道中以创建下一个阶段的‘纠正提示’。通过集成语法检查器在LLM代码生成管道中，可以更深入地了解代码缺陷，并更好地准备LLM采取纠正措施。</li>
<li>形式验证：通过符号模型检查进行程序和算法的形式验证是部署PLC代码到危险环境中的关键步骤。形式验证工具采用候选代码以及操作的严格约束来证明功能正确性。我们的方法利用接受的静态分析知识在验证管道中使用这些工具来验证LLM生成的代码。<br><img src="/images/Literature5/3.png" alt=" "></li>
</ul>
<h3 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h3><p>为了进行这项研究，我们针对GPT-3、GPT-4、Code Llama 7B和Code Llama 34B进行了全面评估。这些模型代表了当前最先进的一般用途语言模型（GPT-3和GPT-4）和专为代码生成设计的模型（Code Llama 7B和Code Llama 34B），使我们能够研究性能与计算资源之间的权衡。</p>
<h3 id="提示工程"><a href="#提示工程" class="headerlink" title="提示工程"></a>提示工程</h3><p>我们采用了两种提示类型，即零样本提示和单样本提示来生成LLM的输出。单样本提示包含结构化文本语法和代码元素的代表性示例，从而为改进代码生成提供上下文线索。而零样本提示仅请求代码生成，没有任何上下文指导。</p>
<h3 id="LLM微调"><a href="#LLM微调" class="headerlink" title="LLM微调"></a>LLM微调</h3><p>我们通过创建低秩适应（LoRA）对Code Llama 7B和Code Llama 34B进行了微调。GPT-3.5和GPT-4不提供LoRA训练接口，因此我们使用这些模型的默认配置。然后，我们利用这些知识训练了一组用于代码补全和代码修复任务的LoRA，每个模型两组。</p>
<h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>我们从OSCAT IEC 61131-3库生成了训练、验证和测试数据集。具体而言，我们运行自动化测试剔除OSCAT数据集中不合格的ST文件，然后创建三个独立的数据集来广泛测试我们的管道能力：</p>
<ul>
<li>生成数据集：即剔除所有不可编译文件后的OSCAT数据集。</li>
<li>补全数据集：通过随机截断生成数据集中的文件来创建，模拟LLM的代码补全能力。</li>
<li>修复数据集：通过从生成数据集中随机删除行，直到生成的ST文件无法编译为止，用于测试LLM解决特定语法错误的能力。</li>
</ul>
<h3 id="测量指标"><a href="#测量指标" class="headerlink" title="测量指标"></a>测量指标</h3><p>我们的测量指标包括通过率、编译器错误数量和代码质量的人类评估。通过率使用pass@k指标评估，编译器错误率提供对我们方法稳健性的洞察，代码质量评估则通过专家小组的评分来完成。</p>
<h3 id="测试平台"><a href="#测试平台" class="headerlink" title="测试平台"></a>测试平台</h3><p>我们在实验室部署了FischerTechnik制造测试平台（MFTB），这是一个集成平台，用于模拟常见制造过程的小型版本。MFTB是一个复杂的网络物理系统，集成了各种输入和不同类型的输出，用于研究和验证自动化、数字控制系统和操作效率。<br><img src="/images/Literature5/4.png" alt=" "><br><img src="/images/Literature5/5.png" alt=" "></p>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>在本节中，我们展示了我们的方法——LLM4PLC的实证评估结果。我们通过三个关键指标来衡量方法的有效性：通过率、编译器错误计数和人工评估的代码质量。我们还比较了每种解决方案所需的工程时间。这些指标为我们的方法提供了全面的评估，涵盖了代码生成过程中的准确性、鲁棒性和实用性 。</p>
<h3 id="通过率"><a href="#通过率" class="headerlink" title="通过率"></a>通过率</h3><p>为了评估通过率，我们通过LLM4PLC管道的各个阶段对40个专用测试文件集进行了测试。对于每个生成的40个输入文件，我们确定了通过率。结果表明，随着我们在各个阶段添加更多组件，通过率逐步提高，反映了我们提出的方法的有效性。特别是在包含单次提示、LoRA和语法检查器的最终阶段，Code Llama 34B模型的通过率达到了72.5% 。</p>
<h3 id="编译器错误计数"><a href="#编译器错误计数" class="headerlink" title="编译器错误计数"></a>编译器错误计数</h3><p>接下来，我们计算了每个输出代码文件生成的编译器错误数量。然后我们对测试文件集中的错误数量进行平均，以规范化结果。结果显示，LoRA和语法检查配置的错误数高于单次提示。然而，随着管道的进展，我们的管道能够纠正这些错误，使得LoRA和语法检查的编译通过率高于单次提示配置 。</p>
<h3 id="人工质量评估"><a href="#人工质量评估" class="headerlink" title="人工质量评估"></a>人工质量评估</h3><p>代码质量的人工评估使用了由各种PLC编程经验的专家组成的小组。专家们根据预定的标准评估生成的代码，包括正确性、可维护性和符合行业编码标准。高分表明我们的方法在生成可读且易于维护的代码方面的实用性，显示出其无缝集成到现有人工驱动开发过程中的潜力 。</p>
<h3 id="工程时间"><a href="#工程时间" class="headerlink" title="工程时间"></a>工程时间</h3><p>在选择GPT基础的解决方案、LoRA增强的LLM和传统的手工编程技术时，工程时间是一个关键问题。我们的实证研究显示了每种方法所需时间的显著差异。GPT模型的设置非常高效，通常只需几分钟即可集成API并开始代码生成。而为现有开源模型（如Code Llama）设置LoRA则需要大量时间来收集数据和进行训练。手工编程PLC尽管是一个理解度很高的方法，但也是最耗时的，通常比基于LLM的方法需要更多的时间和专业人力资源投入 。<br><img src="/images/Literature5/6.png" alt=" "><br><img src="/images/Literature5/7.png" alt=" "></p>
<h1 id="评价和感想（Evaluation-and-Reflections）"><a href="#评价和感想（Evaluation-and-Reflections）" class="headerlink" title="评价和感想（Evaluation and Reflections）"></a>评价和感想（Evaluation and Reflections）</h1><p>LLM4PLC方向非常扎实的工作，可以复现作为后续研究的基础。</p>
<h1 id="未来研究方向（Future-Research-Directions）"><a href="#未来研究方向（Future-Research-Directions）" class="headerlink" title="未来研究方向（Future Research Directions）"></a>未来研究方向（Future Research Directions）</h1><p>结合仿真进行进一步优化，降低成本的同时优化代码生成、自反馈机制。</p>
<h1 id="参考文献（References）"><a href="#参考文献（References）" class="headerlink" title="参考文献（References）"></a>参考文献（References）</h1><p><a href="https://arxiv.org/pdf/2401.05443">https://arxiv.org/pdf/2401.05443</a><br>Fakih, M., Dharmaji, R., Moghaddas, Y., Araya, G. Q., Ogundare, O., &amp; Faruque, M. A. A. (2024). LLM4PLC: Harnessing Large Language Models for Verifiable Programming of PLCs in Industrial Control Systems. arXiv preprint arXiv:2401.05443.</p>
]]></content>
      <categories>
        <category>文献调研</category>
      </categories>
      <tags>
        <tag>Formal software verification</tag>
        <tag>Automatic programming</tag>
        <tag>Natural language processing</tag>
      </tags>
  </entry>
  <entry>
    <title>Resource-Efficient Neural Networks for Embedded Systems</title>
    <url>/2024/05/27/Resource-Efficient%20Neural%20Networks%20for%20Embedded%20Systems/</url>
    <content><![CDATA[<h1 id="标题（Title）"><a href="#标题（Title）" class="headerlink" title="标题（Title）"></a>标题（Title）</h1><p>Resource-Efficient Neural Networks for Embedded Systems<br>基于嵌入式系统的高效神经网络，看标题应该是在嵌入式系统资源受限的情况下，部署合适的神经网络。<br>Submitted 8&#x2F;18; Revised 12&#x2F;23; Published 2&#x2F;24 </p>
<h1 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h1><p>深度学习，特别是当下的大模型对资源的消耗是巨大的。而嵌入式设备天然又具备资源受限的属性，那么如何平衡性能和资源消耗就成了嵌入式设备利用人工智能成果的一项重大挑战。显然未来当AI发展到一定程度，一定时需要大规模部署到嵌入式设备中，让其更好的服务于人类社会的，由此看来，此项研究意义重大。<br>本文是综述，主要研究了目前DNN模型压缩的方法，以及在一些硬件上的兼容情况，详细说明如下；</p>
<span id="more"></span>
<p>DNN模型压缩方法</p>
<ul>
<li>量化神经网络：通过减少权重和激活值的位数来降低内存和计算需求。</li>
<li>网络剪枝：通过移除不必要的权重或神经元来减少计算和内存需求。</li>
<li>结构效率：通过优化神经网络的结构来提高资源利用率，例如知识蒸馏、权重共享和特殊矩阵结构。</li>
</ul>
<p>技术应用与优化<br>这些技术可以在训练期间或作为后处理步骤应用，以减少计算需求，提高内存占用效率和推理速度，降低能源消耗。</p>
<p>嵌入式硬件兼容性<br>文献还讨论了不同类型的嵌入式硬件（如CPU、GPU和FPGA）与DNN的兼容性，及其在能量和延迟方面的潜力和限制。</p>
<h1 id="背景（Background）"><a href="#背景（Background）" class="headerlink" title="背景（Background）"></a>背景（Background）</h1><p>进一步说，嵌入式环境下，深度学习面临三方面的挑战，分别是：表示效率（内存）、计算效率（推理速度）、预测质量（准确性），嵌入式环境下，我们需要找到嵌入式资源下能够达到的最佳状态，显然是极具挑战的。<br><img src="/images/Resource-Efficient-NN-for-Embedded-Systems/1.PNG" alt=" "><br>目前的主要解决方案如下：<br>文献识别了增强深度神经网络（DNN）资源效率的三大主要研究方向，分别是量化神经网络、网络剪枝和结构效率。下面详细介绍这三个研究方向：</p>
<p>量化神经网络（Quantized Neural Networks）<br>量化是通过减少权重和激活值的位数来降低内存占用和计算需求的方法。传统DNN使用32位浮点数来存储和计算权重，而量化技术则将这些数值压缩为更少的位数，例如16位、8位，甚至1位或2位。主要技术包括：</p>
<ul>
<li>定点数和浮点数量化：将32位浮点数量化为更少位数的定点数或浮点数。例如，8位定点数量化在不显著损失精度的情况下大幅减少了存储需求和计算复杂度。</li>
<li>二值化和三值化：将权重和激活值量化为二值（-1, 1）或三值（-1, 0, 1）。这可以显著减少乘法运算，许多计算可以通过简单的逻辑运算（如XNOR和bitcount）来实现，从而大幅提高计算效率。</li>
<li>逐层量化：对每一层使用不同的量化级别，以在不显著影响整体性能的情况下进一步优化资源使用。</li>
</ul>
<p>网络剪枝（Network Pruning）<br>剪枝是通过移除神经网络中的某些权重或神经元来减少模型复杂度和计算需求的方法。剪枝技术可以在训练过程中或训练后进行，主要技术包括：</p>
<ul>
<li>非结构化剪枝：删除权重值较小的个别连接。这种方法较为灵活，但需要稀疏矩阵操作来实际获得计算性能的提升。</li>
<li>结构化剪枝：删除整个神经元、通道或层，这使得剩余部分的结构仍然保持致密，便于利用现有的高效密集矩阵运算库。这种方法在删除大块冗余部分时更高效，但可能对精度有更大影响。</li>
<li>动态剪枝：根据输入数据的特性，动态决定计算哪些部分。这种方法可以在推理过程中根据需要进行剪枝，从而提高计算效率。</li>
</ul>
<p>结构效率（Structural Efficiency）<br>结构效率是通过优化神经网络的结构设计以提高资源利用率的方法。主要技术包括：</p>
<ul>
<li>知识蒸馏：将大模型（教师模型）中的知识转移到小模型（学生模型）中，使得学生模型在保持高精度的同时，具有更低的复杂度和资源需求。学生模型通过模仿教师模型的输出软标签进行训练。</li>
<li>权重共享：在网络中共享部分权重，以减少参数数量。例如，使用哈希函数将网络连接分组到相同的权重“桶”中，这样可以大幅减少需要存储和计算的独立权重数量。</li>
<li>特殊矩阵结构：利用特定的矩阵结构来减少参数和计算量。例如，使用稀疏矩阵或低秩分解的方法，减少全连接层或卷积层中的参数数量和计算复杂度。</li>
</ul>
<h1 id="主要内容（Main-Content）"><a href="#主要内容（Main-Content）" class="headerlink" title="主要内容（Main Content）"></a>主要内容（Main Content）</h1><p>硬件平台介绍</p>
<ul>
<li>CPU（中央处理器）：多线程和向量化提升性能，适合处理稀疏矩阵操作。</li>
<li>GPU（图形处理单元）：具有高并行性和大内存带宽，适合结构化计算。</li>
<li>FPGA（现场可编程门阵列）：高度灵活，可定制化，适合压缩的DNNs。</li>
<li>专用领域加速器（TPU等）：专门为特定任务优化的硬件，如TPU适合密集计算。</li>
<li>回路架构：固定处理器和内存系统，适合通用计算但频繁片外内存访问。</li>
<li>数据流架构：可重构处理器和内存系统，实现高效流水线推理，但开发成本高。</li>
</ul>
<p>实验设置<br><img src="/images/Resource-Efficient-NN-for-Embedded-Systems/2.PNG" alt=" "></p>
<p>研究方向总结</p>
<ol>
<li>量化（Quantization）：</li>
</ol>
<ul>
<li>发现：成功的方法通常将实值表示与量化相结合，以增强计算密集操作的效率。混合精度量化（bit widths在训练期间确定）是一个新兴的主题。</li>
</ul>
<ol start="2">
<li>剪枝（Pruning）：</li>
</ol>
<ul>
<li>发现：趋势正在向结构化剪枝发展，这种方法得到的较小模型的数据结构兼容于高度优化的密集张量操作。</li>
</ul>
<ol start="3">
<li>结构效率（Structural Efficiency）：</li>
</ol>
<ul>
<li>发现：在DNN结构层面上，已经取得了很大进展，开发出既能保持高表达能力又能显著减少计算开销的特定架构。新兴的神经架构搜索（NAS）方法有望自动设计特定应用的高效架构，减少用户干预。</li>
</ul>
<p>实验结果和硬件目标</p>
<ul>
<li>实验结果：在两个基准数据集上展示了在预测质量、表示效率和计算效率之间找到良好折衷方案的难度。实验表明，推理效率需要大量的并行性，并且量化和结构化剪枝在这些加速器上映射良好。</li>
<li>硬件属性：硬件特性和相应的计算效率构成了资源效率的很大一部分，这突显了在寻找资源高效的机器学习模型时需要考虑特定的硬件目标。<br><img src="/images/Resource-Efficient-NN-for-Embedded-Systems/3.PNG" alt=" "></li>
</ul>
<h1 id="评价和感想（Evaluation-and-Reflections）"><a href="#评价和感想（Evaluation-and-Reflections）" class="headerlink" title="评价和感想（Evaluation and Reflections）"></a>评价和感想（Evaluation and Reflections）</h1><p>这是一个很有前景的研究方向，但我对模型提升资源利用率方面还没有任何接触，这篇文献算是初步对这个方向有一些认识，了解一些主流的方案。</p>
<h1 id="未来研究方向（Future-Research-Directions）"><a href="#未来研究方向（Future-Research-Directions）" class="headerlink" title="未来研究方向（Future Research Directions）"></a>未来研究方向（Future Research Directions）</h1><ul>
<li>混合量化精度</li>
<li>结构化剪枝</li>
<li>神经架构搜索（NAS）方法</li>
</ul>
<h1 id="参考文献（References）"><a href="#参考文献（References）" class="headerlink" title="参考文献（References）"></a>参考文献（References）</h1><p><a href="https://www.jmlr.org/papers/volume25/18-566/18-566.pdf">https://www.jmlr.org/papers/volume25/18-566/18-566.pdf</a><br>Roth, W., Schindler, G., Klein, B., Peharz, R., Tschiatschek, S., Fröning, H., … &amp; Ghahramani, Z. (2024). Resource-efficient neural networks for embedded systems. Journal of Machine Learning Research, 25(50), 1-51.</p>
]]></content>
      <categories>
        <category>文献调研</category>
      </categories>
      <tags>
        <tag>Resource-efficient machine learning</tag>
        <tag>inference</tag>
        <tag>deep neural networks.</tag>
      </tags>
  </entry>
  <entry>
    <title>下拉电阻、上拉电阻</title>
    <url>/2024/05/02/%E4%B8%8B%E6%8B%89%E7%94%B5%E9%98%BB%E3%80%81%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB/</url>
    <content><![CDATA[<p>下拉电阻可以将一个不确定的信号钳位在低电平。<br>上拉电阻可以增强输出引脚的驱动能力。</p>
<span id="more"></span>
<h1 id="悬空状态"><a href="#悬空状态" class="headerlink" title="悬空状态"></a>悬空状态</h1><p>如图所示，当基极什么都不接的时候，该点的电压就是悬空状态。此时如果转化为数字信号，其既可能输出0，也可能输出1。<br><img src="/images/%E4%B8%8B%E6%8B%89%E7%94%B5%E9%98%BB%E3%80%81%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB/1.png" alt=" "></p>
<h1 id="下拉"><a href="#下拉" class="headerlink" title="下拉"></a>下拉</h1><p>此时，将该点连接一个电阻接地，由于该电路中NP结电阻无穷大，分走所有电压，所以此时该点的电压变为0，确定性的输出了0电压。<br><img src="/images/%E4%B8%8B%E6%8B%89%E7%94%B5%E9%98%BB%E3%80%81%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB/2.png" alt=" "><br>该电阻存在的必要性是让该点同样可以输出高电压，如下图所示：<br><img src="/images/%E4%B8%8B%E6%8B%89%E7%94%B5%E9%98%BB%E3%80%81%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB/3.png" alt=" "></p>
<h1 id="上拉"><a href="#上拉" class="headerlink" title="上拉"></a>上拉</h1><p>如图所示，上拉电阻的作用是将其与单片机内的等效电阻并联，让整体电阻变小，从而分走更少的电压，这样就可以提升输出点的电压了。<br><img src="/images/%E4%B8%8B%E6%8B%89%E7%94%B5%E9%98%BB%E3%80%81%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB/4.png" alt=" "><br>同样，上拉电阻也能解决悬空状态的问题，如图所示，如果想要输出高电平，同样可以通过并联电阻解决。<br><img src="/images/%E4%B8%8B%E6%8B%89%E7%94%B5%E9%98%BB%E3%80%81%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB/5.png" alt=" "><br>并联后，上面的电阻变小，而下方电阻为无穷大，所有电压将被下方分走。<br><img src="/images/%E4%B8%8B%E6%8B%89%E7%94%B5%E9%98%BB%E3%80%81%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB/6.png" alt=" "><br>参考来源：B站爱上半导体</p>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>数字电路</tag>
        <tag>上拉电阻</tag>
        <tag>下拉电阻</tag>
      </tags>
  </entry>
  <entry>
    <title>从原子到数字电路元器件</title>
    <url>/2024/04/29/%E4%BB%8E%E5%8E%9F%E5%AD%90%E5%88%B0%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="从原子出发"><a href="#从原子出发" class="headerlink" title="从原子出发"></a>从原子出发</h1><p>原子由中子、质子、电子构成，质子带正电、电子带负电。不同原子因最外层电子数量不同而容易失去或者得到电子，呈现出正电性或者负电性。<br><img src="/images/%E4%BB%8E%E5%8E%9F%E5%AD%90%E5%88%B0%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6/1.PNG" alt=" "></p>
<span id="more"></span>

<h1 id="半导体"><a href="#半导体" class="headerlink" title="半导体"></a>半导体</h1><p>硅的最外层有4个电子，处于导体和绝缘体之间，被称为半导体。一堆硅原子在一起会通过共用电子形成共价键得到稳定结构。<br><img src="/images/%E4%BB%8E%E5%8E%9F%E5%AD%90%E5%88%B0%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6/2.PNG" alt=" "></p>
<h1 id="给半导体加点料"><a href="#给半导体加点料" class="headerlink" title="给半导体加点料"></a>给半导体加点料</h1><p>在纯净的硅中掺杂最外层带5个电子的磷元素和带3个电子的硼元素，由于原子最外层无法形成稳定的8电子结构，其导电性上升。<br><img src="/images/%E4%BB%8E%E5%8E%9F%E5%AD%90%E5%88%B0%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6/3.PNG" alt=" "></p>
<h1 id="PN结"><a href="#PN结" class="headerlink" title="PN结"></a>PN结</h1><p>将上述两种半导体拼接，P型半导体倾向于得到电子，显负电性，N型半导体倾向于失去电子，显正电性。此时将会在中间形成一个电场，阻止电子继续移动。<br><img src="/images/%E4%BB%8E%E5%8E%9F%E5%AD%90%E5%88%B0%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6/4.PNG" alt=" "></p>
<h1 id="二极管"><a href="#二极管" class="headerlink" title="二极管"></a>二极管</h1><p>当我们施加外部电场客服耗尽层中形成的电场时，电路会被导通，反之如果加强电场，则电路无法导通。可以分析N型半导体端应该接负极，P型半导体端接正极，方能克服电场，让电路导通。</p>
<h1 id="MOS"><a href="#MOS" class="headerlink" title="MOS"></a>MOS</h1><p>继续利用半导体设计现代计算机需要的元器件。如图所示，一块大的半导体整体为P型，左右两边各有一小块N型，此时无论如何连接电路，都会存在方向相反的两个等效二极管存在，因此无法导通。但我们在中间位置加一个类似电容的结构，通电后形成电场，让电子集中到上方。此时其等效为一个N型半导体，也就是说中间一整块都成了N型半导体，此时电路导通。<br><img src="/images/%E4%BB%8E%E5%8E%9F%E5%AD%90%E5%88%B0%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6/5.PNG" alt=" "></p>
<h1 id="PMOS-NMOS"><a href="#PMOS-NMOS" class="headerlink" title="PMOS&amp;NMOS"></a>PMOS&amp;NMOS</h1><p>NMOS的工作模式是栅极接入正向偏压才导通，而PMOS是栅极接入负向偏压才导通<br><img src="/images/%E4%BB%8E%E5%8E%9F%E5%AD%90%E5%88%B0%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6/6.PNG" alt=" "></p>
<h1 id="符号化"><a href="#符号化" class="headerlink" title="符号化"></a>符号化</h1><p><img src="/images/%E4%BB%8E%E5%8E%9F%E5%AD%90%E5%88%B0%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6/7.PNG" alt=" "></p>
<h1 id="用MOS管构造第一个元器件"><a href="#用MOS管构造第一个元器件" class="headerlink" title="用MOS管构造第一个元器件"></a>用MOS管构造第一个元器件</h1><p>将NMOS和PMOS如图所示连接，其中VDD表示相对高压、VSS表示相对低压，此时A端接高压NMOS导通，NMOS接VSS输出低电压；A端接低压PMOS导通，PMOS接VDD输出高电压。此时高电压用1表示、低电压用0表示，我们就得到了基本元器件，非门。<br><img src="/images/%E4%BB%8E%E5%8E%9F%E5%AD%90%E5%88%B0%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6/8.PNG" alt=" "></p>
<h1 id="进入数字电路时代"><a href="#进入数字电路时代" class="headerlink" title="进入数字电路时代"></a>进入数字电路时代</h1><p><img src="/images/%E4%BB%8E%E5%8E%9F%E5%AD%90%E5%88%B0%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6/9.PNG" alt=" "><br>参考来源：B站硬件茶谈</p>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>数字电路</tag>
        <tag>半导体</tag>
        <tag>门电路</tag>
      </tags>
  </entry>
  <entry>
    <title>从锁存器到RAM</title>
    <url>/2024/05/02/%E4%BB%8E%E9%94%81%E5%AD%98%E5%99%A8%E5%88%B0RAM/</url>
    <content><![CDATA[<p>当电路中输出和输入相关时，我们就有机会得到带有存储功能的电路了，最简单的例子是SR锁存器。</p>
<h1 id="SR锁存器"><a href="#SR锁存器" class="headerlink" title="SR锁存器"></a>SR锁存器</h1><p><img src="/images/%E4%BB%8E%E9%94%81%E5%AD%98%E5%99%A8%E5%88%B0RAM/1.png" alt=" "></p>
<span id="more"></span>

<p>分析该电路时，我们从确定性的角度出发，对于与非门，任何一端输入0，结果一定是1。那么我们很容易知道，(S, R) &#x3D; (0, 1), (1, 0), (1, 1)的情况。但当其为(0, 0)时，其保持上一阶段的状态，这就起到了保存一位数据的作用。<br><img src="/images/%E4%BB%8E%E9%94%81%E5%AD%98%E5%99%A8%E5%88%B0RAM/2.png" alt=" "></p>
<h1 id="D触发器"><a href="#D触发器" class="headerlink" title="D触发器"></a>D触发器</h1><p>为了解决多个SR触发器无法同时动作以及SR触发器(1, 1)为非法状态的问题，我们引入D触发器，其电路示意图如下。<br><img src="/images/%E4%BB%8E%E9%94%81%E5%AD%98%E5%99%A8%E5%88%B0RAM/3.png" alt=" "></p>
<h1 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h1><p>由此，我们就可以构建RAM了，也就是我们所说的内存或者Cache。其基本结构是MOS管，通过行选和列选信号确定一bit的数据，并通过读写控制信号控制读或者写。<br><img src="/images/%E4%BB%8E%E9%94%81%E5%AD%98%E5%99%A8%E5%88%B0RAM/4.png" alt=" "><br>一共用了8个MOS管，速度非常快，但是集成度做不上去，因此只用在Cache上。</p>
<h1 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h1><p>为了提高集成度，我们使用电容做数据存储的媒介，MOS管作为开关。但电容会缓慢放电，因此为了维持数据，其需要不断被补充电荷，这个过程就是刷新。因此这种RAM被称为动态RAM，DRAM用于内存。<br><img src="/images/%E4%BB%8E%E9%94%81%E5%AD%98%E5%99%A8%E5%88%B0RAM/5.png" alt=" "><br>参考来源：B站Ele实验室</p>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>数字电路</tag>
        <tag>RAM</tag>
      </tags>
  </entry>
  <entry>
    <title>基于YOLOv10的摄像头实时检测</title>
    <url>/2024/06/01/%E5%9F%BA%E4%BA%8EYOLOv10%E7%9A%84%E6%91%84%E5%83%8F%E5%A4%B4%E5%AE%9E%E6%97%B6%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<p>本项目基于开源项目：<a href="https://github.com/THU-MIG/yolov10?tab=readme-ov-file">https://github.com/THU-MIG/yolov10?tab=readme-ov-file</a><br>实现一个简单的实时检测效果。</p>
<span id="more"></span>
<h1 id="Start-capturing-from-the-webcam"><a href="#Start-capturing-from-the-webcam" class="headerlink" title="Start capturing from the webcam"></a>Start capturing from the webcam</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>) <span class="comment"># 从默认摄像头获取数据</span></span><br><span class="line">cap.<span class="built_in">set</span>(<span class="number">3</span>, <span class="number">640</span>)</span><br><span class="line">cap.<span class="built_in">set</span>(<span class="number">4</span>, <span class="number">480</span>) <span class="comment"># 设置显示图像的长和宽</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, img= cap.read()</span><br><span class="line">    cv2.imshow(<span class="string">&#x27;Webcam&#x27;</span>, img) <span class="comment"># 显示图像</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span> <span class="comment"># 设置退出条件</span></span><br><span class="line"></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h1 id="Complete-code-—-object-detection-with-YOLO-and-webcam"><a href="#Complete-code-—-object-detection-with-YOLO-and-webcam" class="headerlink" title="Complete code — object detection with YOLO and webcam"></a>Complete code — object detection with YOLO and webcam</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> ultralytics <span class="keyword">import</span> YOLOv10 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型路径和配置</span></span><br><span class="line">image_size = <span class="number">640</span></span><br><span class="line">conf_threshold = <span class="number">0.25</span></span><br><span class="line">model_path = <span class="string">&#x27;/yolov10-main/yolov10b.pt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载模型</span></span><br><span class="line">model = YOLOv10(model_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开摄像头</span></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">cap.<span class="built_in">set</span>(<span class="number">3</span>, <span class="number">640</span>)</span><br><span class="line">cap.<span class="built_in">set</span>(<span class="number">4</span>, <span class="number">480</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, img = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用模型进行预测</span></span><br><span class="line">    results = model.predict(source=img, imgsz=image_size, conf=conf_threshold, save=<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取标注后的图像</span></span><br><span class="line">    annotated_img = results[<span class="number">0</span>].plot()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 显示结果</span></span><br><span class="line">    cv2.imshow(<span class="string">&#x27;YOLOv10 Real Time Dectection&#x27;</span>, annotated_img)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放资源</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>这是一个简单版本，更精美的方法可以用gradio实现。</p>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="/images/%E5%9F%BA%E4%BA%8EYOLOv10%E7%9A%84%E6%91%84%E5%83%8F%E5%A4%B4%E5%AE%9E%E6%97%B6%E6%A3%80%E6%B5%8B/1.jpeg" alt=" "><br>参考文献<br><a href="https://dipankarmedh1.medium.com/real-time-object-detection-with-yolo-and-webcam-enhancing-your-computer-vision-skills-861b97c78993">https://dipankarmedh1.medium.com/real-time-object-detection-with-yolo-and-webcam-enhancing-your-computer-vision-skills-861b97c78993</a></p>
]]></content>
      <categories>
        <category>项目实践</category>
      </categories>
      <tags>
        <tag>YOLO</tag>
        <tag>目标检测</tag>
      </tags>
  </entry>
  <entry>
    <title>直流电机</title>
    <url>/2024/05/21/%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="直流电机简介"><a href="#直流电机简介" class="headerlink" title="直流电机简介"></a>直流电机简介</h1><p>直流电机（Direct Current Motor）是一种将直流电能转换为机械能的电动机，广泛应用于各种需要精确控制速度和位置的机械系统中。直流电机因其调速范围广、启动性能好、控制简单等特点，在工业、家用电器、机器人等领域得到广泛应用。<br>直流电机的工作原理<br>直流电机的基本工作原理是利用电磁感应定律和电磁力相互作用。当直流电流通过电机的线圈（绕组）时，在线圈周围产生磁场，这个磁场与电机磁极的磁场相互作用，产生电磁力，推动电机转子旋转。<br><img src="/images/%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA/1.PNG" alt=" "></p>
<span id="more"></span>
<p><img src="/images/%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA/2.PNG" alt=" "></p>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><ol>
<li>定子（Stator）：</li>
</ol>
<ul>
<li>定子是直流电机的静止部分，通常包括磁极、机座和电刷装置。</li>
<li>磁极：定子中的磁极产生恒定磁场，通常由永磁体或电磁铁构成。</li>
</ul>
<ol start="2">
<li>转子（Rotor）：</li>
</ol>
<ul>
<li>转子是直流电机的旋转部分，通常包括绕组和换向器。</li>
<li>绕组：绕组是由导线绕成的线圈，当电流通过时产生电磁力。</li>
<li>换向器：换向器与电刷接触，负责改变绕组中的电流方向，确保转子连续旋转。</li>
</ul>
<ol start="3">
<li>电刷（Brush）：</li>
</ol>
<ul>
<li>电刷是与换向器接触的部分，通常由石墨制成，用于将电流传递给转子绕组。</li>
</ul>
<h1 id="直流电机的控制"><a href="#直流电机的控制" class="headerlink" title="直流电机的控制"></a>直流电机的控制</h1><p>直流电机的控制主要包括速度控制和位置控制两大方面。</p>
<ol>
<li>速度控制：</li>
</ol>
<ul>
<li>调压控制：通过改变电机输入电压来调节速度。</li>
<li>PWM控制（脉宽调制）：通过调节电机输入电压的占空比来控制速度，常用于电子控制器中。</li>
</ul>
<ol start="2">
<li>位置控制：</li>
</ol>
<ul>
<li>开环控制：不使用反馈信号，控制简单，适用于精度要求不高的场合。</li>
<li>闭环控制：使用反馈信号（如编码器信号）进行精确控制，适用于精度要求高的场合，如机器人、数控机床等。<br>PWM的思路就是利用定时器中断计数，划分一定的范围不供电，在高频下显出的效果就是电机转速的变化。<br><img src="/images/%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA/3.PNG" alt=" "></li>
</ul>
]]></content>
      <categories>
        <category>元件模块</category>
      </categories>
      <tags>
        <tag>电磁力</tag>
        <tag>脉宽调制</tag>
      </tags>
  </entry>
  <entry>
    <title>红外遥控</title>
    <url>/2024/05/21/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7/</url>
    <content><![CDATA[<p>简单来说，红外遥控的过程是红外发送LED发射红外光信号，红外接受LED接受信号，信号转化为高低电频之后需要满足一定的协议方可正常工作。</p>
<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>接收端红外二极管反向接入，红外光照射下电阻减小。未照射时输出高电平、照射时输出低电平。<br><img src="/images/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7/1.PNG" alt=" "></p>
<span id="more"></span>
<p>红外发射端发射的是高频脉冲（为了增强抗干扰能力），通过脉冲信号表示0、1以及起始和结束。<br><img src="/images/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7/2.PNG" alt=" "><br><img src="/images/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7/3.PNG" alt=" "><br><img src="/images/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7/4.PNG" alt=" "><br>红外信号的协议规定：起始码、地址码、地址反码（校验作用）、数据码、数据反码、（重复码）、结束码<br><img src="/images/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7/5.PNG" alt=" "><br><img src="/images/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7/6.PNG" alt=" "><br>不同设备可以用不同的地址码<br><img src="/images/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7/7.PNG" alt=" "><br>面对高频脉冲，处理并不容易，这里红外三极管，并加上一个专用芯片，将脉冲信号转化为数字信号。<br><img src="/images/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7/8.PNG" alt=" "><br><img src="/images/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7/9.PNG" alt=" "></p>
<h1 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h1><p>由于红外信号持续时间短，一旦接收到相关信号应该立即处理，这就是需要外部中断了。<br><img src="/images/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7/10.PNG" alt=" "><br>外部中断INT0, INT1接收信号，并选择通过哪种方式出发。EX0, EX1, EA使能，PX0设置优先级。</p>
]]></content>
      <categories>
        <category>元件模块</category>
      </categories>
      <tags>
        <tag>光敏电阻</tag>
        <tag>外部中断</tag>
      </tags>
  </entry>
  <entry>
    <title>蜂鸣器</title>
    <url>/2024/05/14/%E8%9C%82%E9%B8%A3%E5%99%A8/</url>
    <content><![CDATA[<p>蜂鸣器可以将电信号转化为声音信号。用于设备的按键音、报警音。<br><img src="/images/%E8%9C%82%E9%B8%A3%E5%99%A8/1.PNG" alt=" "></p>
<span id="more"></span>
<h1 id="蜂鸣器分类"><a href="#蜂鸣器分类" class="headerlink" title="蜂鸣器分类"></a>蜂鸣器分类</h1><p>按照驱动方式可以分为有源蜂鸣器和无源蜂鸣器。区别是内部是否带振荡源，带振荡源的只需要提供直流电压即可发声。</p>
<h1 id="驱动电路"><a href="#驱动电路" class="headerlink" title="驱动电路"></a>驱动电路</h1><p>蜂鸣器往往需要比微控制器引脚能提供的更高的电压，并且为了增强波形、提高设备可靠性和灵活性，驱动电路都必不可少。</p>
<h1 id="三极管驱动"><a href="#三极管驱动" class="headerlink" title="三极管驱动"></a>三极管驱动</h1><p>基极控制三极管导通、截止。VCC提供Buzzer需要的电压。<br><img src="/images/%E8%9C%82%E9%B8%A3%E5%99%A8/2.PNG" alt=" "></p>
<h1 id="集成电路驱动"><a href="#集成电路驱动" class="headerlink" title="集成电路驱动"></a>集成电路驱动</h1><p>ULN2023集成电路，适用于接受低电流信号并转化为能驱动较高电流负载的输出。<br><img src="/images/%E8%9C%82%E9%B8%A3%E5%99%A8/3.PNG" alt=" "></p>
<h1 id="单片机驱动蜂鸣器发声"><a href="#单片机驱动蜂鸣器发声" class="headerlink" title="单片机驱动蜂鸣器发声"></a>单片机驱动蜂鸣器发声</h1><p>通过I&#x2F;O口提供振荡信号，振荡信号的频率决定了蜂鸣器的音高，从而可以制作音乐。<br><img src="/images/%E8%9C%82%E9%B8%A3%E5%99%A8/4.PNG" alt=" "><br>参考来源：B站江科协51单片机教程</p>
]]></content>
      <categories>
        <category>元件模块</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>驱动电路</tag>
      </tags>
  </entry>
</search>
