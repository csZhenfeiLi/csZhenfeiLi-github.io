<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AT24C02</title>
    <url>/2024/05/14/AT24C02/</url>
    <content><![CDATA[<h1 id="ROM-非易失性存储器"><a href="#ROM-非易失性存储器" class="headerlink" title="ROM(非易失性存储器)"></a>ROM(非易失性存储器)</h1><ol>
<li>掩模ROM（Mask ROM）</li>
</ol>
<ul>
<li>掩模ROM在制造过程中就被编程，内容由硅片设计图决定，因此不能被修改。掩模ROM成本在大规模生产时很低，但需要大量的初始投资用于开发掩模。它常用于大批量生产的消费电子产品中。</li>
</ul>
<ol start="2">
<li>可编程ROM（PROM）</li>
</ol>
<ul>
<li>PROM在制造后空白，允许用户一次性编程。编程通常通过烧写设备进行，一旦编程完成，数据就永久保存，无法更改。PROM适合于需要定制固件的应用。<span id="more"></span></li>
</ul>
<ol start="3">
<li>可擦除可编程ROM（EPROM）</li>
</ol>
<ul>
<li>EPROM可以通过紫外线光照射擦除其内容，之后可以重新编程。EPROM的窗口盖上有透明的石英玻璃，用于传输紫外线。这种类型的ROM适用于开发过程中需要多次修改代码的情况。</li>
</ul>
<ol start="4">
<li>电可擦除可编程ROM（EEPROM）</li>
</ol>
<ul>
<li>EEPROM可以在电路内电气地擦除和重新编程，不需要拆除芯片或使用紫外线。它允许按字节进行编程和擦除，提供极大的灵活性。EEPROM适用于需要频繁更新存储数据的应用，如配置设置存储。</li>
</ul>
<ol start="5">
<li>闪存（Flash Memory）</li>
</ol>
<ul>
<li>闪存是一种特殊类型的EEPROM，它支持更快的擦除和更高密度的数据存储。与EEPROM不同，闪存通常按块（而非单个字节）进行擦除和编程。因其高效性和成本效益，闪存广泛用于USB闪存驱动器、固态硬盘、手机和其他便携式电子设备。</li>
</ul>
<h1 id="存储器简化模型"><a href="#存储器简化模型" class="headerlink" title="存储器简化模型"></a>存储器简化模型</h1><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p><img src="/images/AT24C02/1.PNG" alt=" "><br>具体有线选法和重合法，不同的电路设计需要的地址线不同，一次取出的数据位数也不同</p>
<h2 id="线选法"><a href="#线选法" class="headerlink" title="线选法"></a>线选法</h2><p><img src="/images/AT24C02/2.PNG" alt=" "></p>
<h2 id="重合法"><a href="#重合法" class="headerlink" title="重合法"></a>重合法</h2><p><img src="/images/AT24C02/3.PNG" alt=" "><br>Mask ROM出厂就被设置好了，输出1的就加上二极管，否则就不加；PROM有两个二极管，第二个二极管高压容易被击穿，支持一次性烧录。<br><img src="/images/AT24C02/4.PNG" alt=" "></p>
<h1 id="AT24C02"><a href="#AT24C02" class="headerlink" title="AT24C02"></a>AT24C02</h1><p>存储介质：EEPROM<br>通讯接口：I²C总线<br>容量：256字节<br><img src="/images/AT24C02/5.PNG" alt=" "></p>
<h2 id="总线通讯"><a href="#总线通讯" class="headerlink" title="总线通讯"></a>总线通讯</h2><p>为什么需要这个协议？多个设备通讯时，如果两两通讯，将需要极为复杂的电路。如图所示：<br><img src="/images/AT24C02/6.PNG" alt=" "><br>通过总线通讯，上述电路可以大大简化：<br><img src="/images/AT24C02/7.png" alt=" "><br>既然共用数据线，就要解决怎么传输、怎么接收的问题。我们要规定一套规则完成两个设备之间的通讯。</p>
<h2 id="写数据帧"><a href="#写数据帧" class="headerlink" title="写数据帧"></a>写数据帧</h2><p>通过规定好的时序，我们依次写入设备地址、寄存器地址、数据。也就是先选中一个从设备，然后选中AT24C02的地址，再输入一个数据即可。<br><img src="/images/AT24C02/8.png" alt=" "></p>
<h2 id="读数据帧"><a href="#读数据帧" class="headerlink" title="读数据帧"></a>读数据帧</h2><p>类似的，这里是读数据帧<br><img src="/images/AT24C02/9.png" alt=" "></p>
<h2 id="时序信号"><a href="#时序信号" class="headerlink" title="时序信号"></a>时序信号</h2><p><img src="/images/AT24C02/10.png" alt=" "><br>参考来源：GTP-4生成；知乎计算机组成原理学习笔记（三）：存储器（Lucius）；B站爱上半导体</p>
]]></content>
      <categories>
        <category>元件模块</category>
      </categories>
      <tags>
        <tag>ROM</tag>
        <tag>总线通讯</tag>
        <tag>I²C</tag>
      </tags>
  </entry>
  <entry>
    <title>BCD码</title>
    <url>/2024/05/07/BCD%E7%A0%81/</url>
    <content><![CDATA[<p>Binary-Coded Decimal，二进制编码的十进制数。将每个十进制的0-9映射到四个二进制位。显然四位二进制位可以表示16种数字，映射到9个数后必然有一些位是不合法的，同时映射方案不同，得到的BCD码也不一样。</p>
<h1 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h1><p><img src="/images/BCD%E7%A0%81/1.PNG" alt=" "></p>
<span id="more"></span>
<h1 id="8421码"><a href="#8421码" class="headerlink" title="8421码"></a>8421码</h1><p>8421码与十进制数的互相转换：<br>1000 1000 &#x3D; 88<br>DEC &#x3D; BCD &#x2F; 16 * 10 +BCD % 16<br>BCD &#x3D; DEC &#x2F; 10 * 16 + BCD % 10</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>8421码</tag>
      </tags>
  </entry>
  <entry>
    <title>Canvas-Nest设置</title>
    <url>/2024/05/14/Canvas-Nest%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>想设置如下图所示的动态背景，搜了很久没找到适用自己的。通过github源头轻松解决。<br><img src="/images/Canvas-Nest%E8%AE%BE%E7%BD%AE/1.png" alt=" "></p>
<span id="more"></span>
<h1 id="源文件README"><a href="#源文件README" class="headerlink" title="源文件README"></a>源文件README</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Step 1 → Go to Hexo dir</span><br><span class="line"></span><br><span class="line">Change dir to Hexo directory. There must be scaffolds, source, themes and other directories:</span><br><span class="line"></span><br><span class="line">$ cd hexo</span><br><span class="line">$ ls</span><br><span class="line">scaffolds  source  themes  _config.yml  package.json</span><br><span class="line"></span><br><span class="line">Step 2 → Create footer.swig</span><br><span class="line"></span><br><span class="line">Create a file named footer.swig in hexo/source/_data directory (create _data directory if it does not exist).</span><br><span class="line"></span><br><span class="line">Edit this file and add the following content:</span><br><span class="line"></span><br><span class="line">&lt;script color=&quot;0,0,255&quot; opacity=&quot;0.5&quot; zIndex=&quot;-1&quot; count=&quot;99&quot; src=&quot;https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">You can customize these options.</span><br><span class="line">Step 3 → Set it up</span><br><span class="line"></span><br><span class="line">In the NexT _config.yml, uncomment footer under the custom_file_path section.</span><br><span class="line"></span><br><span class="line"># Define custom file paths.</span><br><span class="line"># Create your custom files in site directory `source/_data` and uncomment needed files below.</span><br><span class="line">custom_file_path:</span><br><span class="line">  #head: source/_data/head.swig</span><br><span class="line">  #header: source/_data/header.swig</span><br><span class="line">  #sidebar: source/_data/sidebar.swig</span><br><span class="line">  #postMeta: source/_data/post-meta.swig</span><br><span class="line">  #postBodyEnd: source/_data/post-body-end.swig</span><br><span class="line">  footer: source/_data/footer.swig</span><br><span class="line">  #bodyEnd: source/_data/body-end.swig</span><br><span class="line">  #variable: source/_data/variables.styl</span><br><span class="line">  #mixin: source/_data/mixins.styl</span><br><span class="line">  #style: source/_data/styles.styl</span><br></pre></td></tr></table></figure>
<p> 参考来源：<a href="https://github.com/theme-next/theme-next-canvas-nest">https://github.com/theme-next/theme-next-canvas-nest</a></p>
]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>动态背景</tag>
      </tags>
  </entry>
  <entry>
    <title>DS1302</title>
    <url>/2024/05/07/DS1302/</url>
    <content><![CDATA[<h1 id="模块功能"><a href="#模块功能" class="headerlink" title="模块功能"></a>模块功能</h1><p>提供年、月、日、时、分、秒的计时。</p>
<h1 id="引脚定义"><a href="#引脚定义" class="headerlink" title="引脚定义"></a>引脚定义</h1><p><img src="/images/DS1302/1.png" alt=" "></p>
<span id="more"></span>
<h1 id="应用电路"><a href="#应用电路" class="headerlink" title="应用电路"></a>应用电路</h1><p>VCC1、2：分别是备用电源和主电源，备用电源提供非易失性存储功能。<br>X1和X2表示晶振：32.768KHZ，用于提供时钟信号，晶振的核心是石英晶体，通过改变其形状、尺寸、切割方式而产生不同的频率。<br>CE：Chip Enable，芯片使能。<br>I&#x2F;O：数据输入输出<br>SCLK：串行时钟<br><img src="/images/DS1302/2.png" alt=" "></p>
<h1 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h1><p>晶振提供时钟信号，RAM存储时间信息并提供通用寄存器。通过CE、I&#x2F;O、SCLK接口与RAM交互。<br><img src="/images/DS1302/3.png" alt=" "></p>
<h1 id="在哪儿、读-写？"><a href="#在哪儿、读-写？" class="headerlink" title="在哪儿、读&#x2F;写？"></a>在哪儿、读&#x2F;写？</h1><p>一个字节中，最低位控制读写、第6位选择RAM or CK（上面加一横表示低电平有效）<br><img src="/images/DS1302/4.png" alt=" "><br>WP表示Write Protect，置1时不可写入。<br>TCS是备用电池的设置。<br><img src="/images/DS1302/5.png" alt=" "></p>
<h1 id="时序定义"><a href="#时序定义" class="headerlink" title="时序定义"></a>时序定义</h1><p>CE全程置1；<br>I&#x2F;O上升沿写入单片机、单片机中的数据每个下降沿到I&#x2F;O口处。<br>第一个字节确认读出或写入操作、确认地址（在哪儿操作）。<br>第二个字节操作读出数据或者继续写入数据。<br><img src="/images/DS1302/5.png" alt=" "><br>通过for循环搭配SCLK信号，串行读入或者写出数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DS1302_WriteByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Command, <span class="type">unsigned</span> <span class="type">char</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">        DS1302_CE = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                DS1302_IO = Command &amp; (<span class="number">0x01</span>&lt;&lt;i);</span><br><span class="line">                DS1302_SCLK = <span class="number">1</span>;</span><br><span class="line">                DS1302_SCLK = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                DS1302_IO = Data &amp; (<span class="number">0x01</span>&lt;&lt;i);</span><br><span class="line">                DS1302_SCLK = <span class="number">1</span>;</span><br><span class="line">                DS1302_SCLK = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        DS1302_CE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">DS1302_ReadByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Command)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> i, Data = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">        DS1302_CE = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                DS1302_IO = Command &amp; (<span class="number">0x01</span>&lt;&lt;i);</span><br><span class="line">                DS1302_SCLK = <span class="number">0</span>;</span><br><span class="line">                DS1302_SCLK = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">8</span> ;i++)</span><br><span class="line">        &#123;</span><br><span class="line">                DS1302_SCLK = <span class="number">1</span>;</span><br><span class="line">                DS1302_SCLK = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (DS1302_IO) &#123;Data |= (<span class="number">0x01</span>&lt;&lt;i);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        DS1302_CE = <span class="number">0</span>;</span><br><span class="line">        DS1302_IO = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考来源：DS1302 Trickle-Charge Timekeeping Chip; B站江协科技</p>
]]></content>
      <categories>
        <category>元件模块</category>
      </categories>
      <tags>
        <tag>时钟电路</tag>
        <tag>实时时钟</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>Resource-Efficient Neural Networks for Embedded Systems</title>
    <url>/2024/05/27/Resource-Efficient%20Neural%20Networks%20for%20Embedded%20Systems/</url>
    <content><![CDATA[<h1 id="标题（Title）"><a href="#标题（Title）" class="headerlink" title="标题（Title）"></a>标题（Title）</h1><p>Resource-Efficient Neural Networks for Embedded Systems<br>基于嵌入式系统的高效神经网络，看标题应该是在嵌入式系统资源受限的情况下，部署合适的神经网络。<br>Submitted 8&#x2F;18; Revised 12&#x2F;23; Published 2&#x2F;24 </p>
<h1 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h1><p>深度学习，特别是当下的大模型对资源的消耗是巨大的。而嵌入式设备天然又具备资源受限的属性，那么如何平衡性能和资源消耗就成了嵌入式设备利用人工智能成果的一项重大挑战。显然未来当AI发展到一定程度，一定时需要大规模部署到嵌入式设备中，让其更好的服务于人类社会的，由此看来，此项研究意义重大。<br>本文是综述，主要研究了目前DNN模型压缩的方法，以及在一些硬件上的兼容情况，详细说明如下；</p>
<span id="more"></span>
<p>DNN模型压缩方法</p>
<ul>
<li>量化神经网络：通过减少权重和激活值的位数来降低内存和计算需求。</li>
<li>网络剪枝：通过移除不必要的权重或神经元来减少计算和内存需求。</li>
<li>结构效率：通过优化神经网络的结构来提高资源利用率，例如知识蒸馏、权重共享和特殊矩阵结构。</li>
</ul>
<p>技术应用与优化<br>这些技术可以在训练期间或作为后处理步骤应用，以减少计算需求，提高内存占用效率和推理速度，降低能源消耗。</p>
<p>嵌入式硬件兼容性<br>文献还讨论了不同类型的嵌入式硬件（如CPU、GPU和FPGA）与DNN的兼容性，及其在能量和延迟方面的潜力和限制。</p>
<h1 id="背景（Background）"><a href="#背景（Background）" class="headerlink" title="背景（Background）"></a>背景（Background）</h1><p>进一步说，嵌入式环境下，深度学习面临三方面的挑战，分别是：表示效率（内存）、计算效率（推理速度）、预测质量（准确性），嵌入式环境下，我们需要找到嵌入式资源下能够达到的最佳状态，显然是极具挑战的。<br><img src="/images/Resource-Efficient-NN-for-Embedded-Systems/1.PNG" alt=" "><br>目前的主要解决方案如下：<br>文献识别了增强深度神经网络（DNN）资源效率的三大主要研究方向，分别是量化神经网络、网络剪枝和结构效率。下面详细介绍这三个研究方向：</p>
<p>量化神经网络（Quantized Neural Networks）<br>量化是通过减少权重和激活值的位数来降低内存占用和计算需求的方法。传统DNN使用32位浮点数来存储和计算权重，而量化技术则将这些数值压缩为更少的位数，例如16位、8位，甚至1位或2位。主要技术包括：</p>
<ul>
<li>定点数和浮点数量化：将32位浮点数量化为更少位数的定点数或浮点数。例如，8位定点数量化在不显著损失精度的情况下大幅减少了存储需求和计算复杂度。</li>
<li>二值化和三值化：将权重和激活值量化为二值（-1, 1）或三值（-1, 0, 1）。这可以显著减少乘法运算，许多计算可以通过简单的逻辑运算（如XNOR和bitcount）来实现，从而大幅提高计算效率。</li>
<li>逐层量化：对每一层使用不同的量化级别，以在不显著影响整体性能的情况下进一步优化资源使用。</li>
</ul>
<p>网络剪枝（Network Pruning）<br>剪枝是通过移除神经网络中的某些权重或神经元来减少模型复杂度和计算需求的方法。剪枝技术可以在训练过程中或训练后进行，主要技术包括：</p>
<ul>
<li>非结构化剪枝：删除权重值较小的个别连接。这种方法较为灵活，但需要稀疏矩阵操作来实际获得计算性能的提升。</li>
<li>结构化剪枝：删除整个神经元、通道或层，这使得剩余部分的结构仍然保持致密，便于利用现有的高效密集矩阵运算库。这种方法在删除大块冗余部分时更高效，但可能对精度有更大影响。</li>
<li>动态剪枝：根据输入数据的特性，动态决定计算哪些部分。这种方法可以在推理过程中根据需要进行剪枝，从而提高计算效率。</li>
</ul>
<p>结构效率（Structural Efficiency）<br>结构效率是通过优化神经网络的结构设计以提高资源利用率的方法。主要技术包括：</p>
<ul>
<li>知识蒸馏：将大模型（教师模型）中的知识转移到小模型（学生模型）中，使得学生模型在保持高精度的同时，具有更低的复杂度和资源需求。学生模型通过模仿教师模型的输出软标签进行训练。</li>
<li>权重共享：在网络中共享部分权重，以减少参数数量。例如，使用哈希函数将网络连接分组到相同的权重“桶”中，这样可以大幅减少需要存储和计算的独立权重数量。</li>
<li>特殊矩阵结构：利用特定的矩阵结构来减少参数和计算量。例如，使用稀疏矩阵或低秩分解的方法，减少全连接层或卷积层中的参数数量和计算复杂度。</li>
</ul>
<h1 id="主要内容（Main-Content）"><a href="#主要内容（Main-Content）" class="headerlink" title="主要内容（Main Content）"></a>主要内容（Main Content）</h1><p>硬件平台介绍</p>
<ul>
<li>CPU（中央处理器）：多线程和向量化提升性能，适合处理稀疏矩阵操作。</li>
<li>GPU（图形处理单元）：具有高并行性和大内存带宽，适合结构化计算。</li>
<li>FPGA（现场可编程门阵列）：高度灵活，可定制化，适合压缩的DNNs。</li>
<li>专用领域加速器（TPU等）：专门为特定任务优化的硬件，如TPU适合密集计算。</li>
<li>回路架构：固定处理器和内存系统，适合通用计算但频繁片外内存访问。</li>
<li>数据流架构：可重构处理器和内存系统，实现高效流水线推理，但开发成本高。</li>
</ul>
<p>实验设置<br><img src="/images/Resource-Efficient-NN-for-Embedded-Systems/2.PNG" alt=" "></p>
<p>研究方向总结</p>
<ol>
<li>量化（Quantization）：</li>
</ol>
<ul>
<li>发现：成功的方法通常将实值表示与量化相结合，以增强计算密集操作的效率。混合精度量化（bit widths在训练期间确定）是一个新兴的主题。</li>
</ul>
<ol start="2">
<li>剪枝（Pruning）：</li>
</ol>
<ul>
<li>发现：趋势正在向结构化剪枝发展，这种方法得到的较小模型的数据结构兼容于高度优化的密集张量操作。</li>
</ul>
<ol start="3">
<li>结构效率（Structural Efficiency）：</li>
</ol>
<ul>
<li>发现：在DNN结构层面上，已经取得了很大进展，开发出既能保持高表达能力又能显著减少计算开销的特定架构。新兴的神经架构搜索（NAS）方法有望自动设计特定应用的高效架构，减少用户干预。</li>
</ul>
<p>实验结果和硬件目标</p>
<ul>
<li>实验结果：在两个基准数据集上展示了在预测质量、表示效率和计算效率之间找到良好折衷方案的难度。实验表明，推理效率需要大量的并行性，并且量化和结构化剪枝在这些加速器上映射良好。</li>
<li>硬件属性：硬件特性和相应的计算效率构成了资源效率的很大一部分，这突显了在寻找资源高效的机器学习模型时需要考虑特定的硬件目标。<br><img src="/images/Resource-Efficient-NN-for-Embedded-Systems/3.PNG" alt=" "></li>
</ul>
<h1 id="评价和感想（Evaluation-and-Reflections）"><a href="#评价和感想（Evaluation-and-Reflections）" class="headerlink" title="评价和感想（Evaluation and Reflections）"></a>评价和感想（Evaluation and Reflections）</h1><p>这是一个很有前景的研究方向，但我对模型提升资源利用率方面还没有任何接触，这篇文献算是初步对这个方向有一些认识，了解一些主流的方案。</p>
<h1 id="未来研究方向（Future-Research-Directions）"><a href="#未来研究方向（Future-Research-Directions）" class="headerlink" title="未来研究方向（Future Research Directions）"></a>未来研究方向（Future Research Directions）</h1><ul>
<li>混合量化精度</li>
<li>结构化剪枝</li>
<li>神经架构搜索（NAS）方法</li>
</ul>
<h1 id="参考文献（References）"><a href="#参考文献（References）" class="headerlink" title="参考文献（References）"></a>参考文献（References）</h1><p><a href="https://www.jmlr.org/papers/volume25/18-566/18-566.pdf">https://www.jmlr.org/papers/volume25/18-566/18-566.pdf</a><br>Roth, W., Schindler, G., Klein, B., Peharz, R., Tschiatschek, S., Fröning, H., … &amp; Ghahramani, Z. (2024). Resource-efficient neural networks for embedded systems. Journal of Machine Learning Research, 25(50), 1-51.</p>
]]></content>
      <categories>
        <category>文献调研</category>
      </categories>
      <tags>
        <tag>Resource-efficient machine learning</tag>
        <tag>inference</tag>
        <tag>deep neural networks.</tag>
      </tags>
  </entry>
  <entry>
    <title>下拉电阻、上拉电阻</title>
    <url>/2024/05/02/%E4%B8%8B%E6%8B%89%E7%94%B5%E9%98%BB%E3%80%81%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB/</url>
    <content><![CDATA[<p>下拉电阻可以将一个不确定的信号钳位在低电平。<br>上拉电阻可以增强输出引脚的驱动能力。</p>
<span id="more"></span>
<h1 id="悬空状态"><a href="#悬空状态" class="headerlink" title="悬空状态"></a>悬空状态</h1><p>如图所示，当基极什么都不接的时候，该点的电压就是悬空状态。此时如果转化为数字信号，其既可能输出0，也可能输出1。<br><img src="/images/%E4%B8%8B%E6%8B%89%E7%94%B5%E9%98%BB%E3%80%81%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB/1.png" alt=" "></p>
<h1 id="下拉"><a href="#下拉" class="headerlink" title="下拉"></a>下拉</h1><p>此时，将该点连接一个电阻接地，由于该电路中NP结电阻无穷大，分走所有电压，所以此时该点的电压变为0，确定性的输出了0电压。<br><img src="/images/%E4%B8%8B%E6%8B%89%E7%94%B5%E9%98%BB%E3%80%81%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB/2.png" alt=" "><br>该电阻存在的必要性是让该点同样可以输出高电压，如下图所示：<br><img src="/images/%E4%B8%8B%E6%8B%89%E7%94%B5%E9%98%BB%E3%80%81%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB/3.png" alt=" "></p>
<h1 id="上拉"><a href="#上拉" class="headerlink" title="上拉"></a>上拉</h1><p>如图所示，上拉电阻的作用是将其与单片机内的等效电阻并联，让整体电阻变小，从而分走更少的电压，这样就可以提升输出点的电压了。<br><img src="/images/%E4%B8%8B%E6%8B%89%E7%94%B5%E9%98%BB%E3%80%81%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB/4.png" alt=" "><br>同样，上拉电阻也能解决悬空状态的问题，如图所示，如果想要输出高电平，同样可以通过并联电阻解决。<br><img src="/images/%E4%B8%8B%E6%8B%89%E7%94%B5%E9%98%BB%E3%80%81%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB/5.png" alt=" "><br>并联后，上面的电阻变小，而下方电阻为无穷大，所有电压将被下方分走。<br><img src="/images/%E4%B8%8B%E6%8B%89%E7%94%B5%E9%98%BB%E3%80%81%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB/6.png" alt=" "><br>参考来源：B站爱上半导体</p>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>数字电路</tag>
        <tag>上拉电阻</tag>
        <tag>下拉电阻</tag>
      </tags>
  </entry>
  <entry>
    <title>从原子到数字电路元器件</title>
    <url>/2024/04/29/%E4%BB%8E%E5%8E%9F%E5%AD%90%E5%88%B0%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="从原子出发"><a href="#从原子出发" class="headerlink" title="从原子出发"></a>从原子出发</h1><p>原子由中子、质子、电子构成，质子带正电、电子带负电。不同原子因最外层电子数量不同而容易失去或者得到电子，呈现出正电性或者负电性。<br><img src="/images/%E4%BB%8E%E5%8E%9F%E5%AD%90%E5%88%B0%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6/1.PNG" alt=" "></p>
<span id="more"></span>

<h1 id="半导体"><a href="#半导体" class="headerlink" title="半导体"></a>半导体</h1><p>硅的最外层有4个电子，处于导体和绝缘体之间，被称为半导体。一堆硅原子在一起会通过共用电子形成共价键得到稳定结构。<br><img src="/images/%E4%BB%8E%E5%8E%9F%E5%AD%90%E5%88%B0%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6/2.PNG" alt=" "></p>
<h1 id="给半导体加点料"><a href="#给半导体加点料" class="headerlink" title="给半导体加点料"></a>给半导体加点料</h1><p>在纯净的硅中掺杂最外层带5个电子的磷元素和带3个电子的硼元素，由于原子最外层无法形成稳定的8电子结构，其导电性上升。<br><img src="/images/%E4%BB%8E%E5%8E%9F%E5%AD%90%E5%88%B0%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6/3.PNG" alt=" "></p>
<h1 id="PN结"><a href="#PN结" class="headerlink" title="PN结"></a>PN结</h1><p>将上述两种半导体拼接，P型半导体倾向于得到电子，显负电性，N型半导体倾向于失去电子，显正电性。此时将会在中间形成一个电场，阻止电子继续移动。<br><img src="/images/%E4%BB%8E%E5%8E%9F%E5%AD%90%E5%88%B0%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6/4.PNG" alt=" "></p>
<h1 id="二极管"><a href="#二极管" class="headerlink" title="二极管"></a>二极管</h1><p>当我们施加外部电场客服耗尽层中形成的电场时，电路会被导通，反之如果加强电场，则电路无法导通。可以分析N型半导体端应该接负极，P型半导体端接正极，方能克服电场，让电路导通。</p>
<h1 id="MOS"><a href="#MOS" class="headerlink" title="MOS"></a>MOS</h1><p>继续利用半导体设计现代计算机需要的元器件。如图所示，一块大的半导体整体为P型，左右两边各有一小块N型，此时无论如何连接电路，都会存在方向相反的两个等效二极管存在，因此无法导通。但我们在中间位置加一个类似电容的结构，通电后形成电场，让电子集中到上方。此时其等效为一个N型半导体，也就是说中间一整块都成了N型半导体，此时电路导通。<br><img src="/images/%E4%BB%8E%E5%8E%9F%E5%AD%90%E5%88%B0%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6/5.PNG" alt=" "></p>
<h1 id="PMOS-NMOS"><a href="#PMOS-NMOS" class="headerlink" title="PMOS&amp;NMOS"></a>PMOS&amp;NMOS</h1><p>NMOS的工作模式是栅极接入正向偏压才导通，而PMOS是栅极接入负向偏压才导通<br><img src="/images/%E4%BB%8E%E5%8E%9F%E5%AD%90%E5%88%B0%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6/6.PNG" alt=" "></p>
<h1 id="符号化"><a href="#符号化" class="headerlink" title="符号化"></a>符号化</h1><p><img src="/images/%E4%BB%8E%E5%8E%9F%E5%AD%90%E5%88%B0%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6/7.PNG" alt=" "></p>
<h1 id="用MOS管构造第一个元器件"><a href="#用MOS管构造第一个元器件" class="headerlink" title="用MOS管构造第一个元器件"></a>用MOS管构造第一个元器件</h1><p>将NMOS和PMOS如图所示连接，其中VDD表示相对高压、VSS表示相对低压，此时A端接高压NMOS导通，NMOS接VSS输出低电压；A端接低压PMOS导通，PMOS接VDD输出高电压。此时高电压用1表示、低电压用0表示，我们就得到了基本元器件，非门。<br><img src="/images/%E4%BB%8E%E5%8E%9F%E5%AD%90%E5%88%B0%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6/8.PNG" alt=" "></p>
<h1 id="进入数字电路时代"><a href="#进入数字电路时代" class="headerlink" title="进入数字电路时代"></a>进入数字电路时代</h1><p><img src="/images/%E4%BB%8E%E5%8E%9F%E5%AD%90%E5%88%B0%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6/9.PNG" alt=" "><br>参考来源：B站硬件茶谈</p>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>数字电路</tag>
        <tag>半导体</tag>
        <tag>门电路</tag>
      </tags>
  </entry>
  <entry>
    <title>从锁存器到RAM</title>
    <url>/2024/05/02/%E4%BB%8E%E9%94%81%E5%AD%98%E5%99%A8%E5%88%B0RAM/</url>
    <content><![CDATA[<p>当电路中输出和输入相关时，我们就有机会得到带有存储功能的电路了，最简单的例子是SR锁存器。</p>
<h1 id="SR锁存器"><a href="#SR锁存器" class="headerlink" title="SR锁存器"></a>SR锁存器</h1><p><img src="/images/%E4%BB%8E%E9%94%81%E5%AD%98%E5%99%A8%E5%88%B0RAM/1.png" alt=" "></p>
<span id="more"></span>

<p>分析该电路时，我们从确定性的角度出发，对于与非门，任何一端输入0，结果一定是1。那么我们很容易知道，(S, R) &#x3D; (0, 1), (1, 0), (1, 1)的情况。但当其为(0, 0)时，其保持上一阶段的状态，这就起到了保存一位数据的作用。<br><img src="/images/%E4%BB%8E%E9%94%81%E5%AD%98%E5%99%A8%E5%88%B0RAM/2.png" alt=" "></p>
<h1 id="D触发器"><a href="#D触发器" class="headerlink" title="D触发器"></a>D触发器</h1><p>为了解决多个SR触发器无法同时动作以及SR触发器(1, 1)为非法状态的问题，我们引入D触发器，其电路示意图如下。<br><img src="/images/%E4%BB%8E%E9%94%81%E5%AD%98%E5%99%A8%E5%88%B0RAM/3.png" alt=" "></p>
<h1 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h1><p>由此，我们就可以构建RAM了，也就是我们所说的内存或者Cache。其基本结构是MOS管，通过行选和列选信号确定一bit的数据，并通过读写控制信号控制读或者写。<br><img src="/images/%E4%BB%8E%E9%94%81%E5%AD%98%E5%99%A8%E5%88%B0RAM/4.png" alt=" "><br>一共用了8个MOS管，速度非常快，但是集成度做不上去，因此只用在Cache上。</p>
<h1 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h1><p>为了提高集成度，我们使用电容做数据存储的媒介，MOS管作为开关。但电容会缓慢放电，因此为了维持数据，其需要不断被补充电荷，这个过程就是刷新。因此这种RAM被称为动态RAM，DRAM用于内存。<br><img src="/images/%E4%BB%8E%E9%94%81%E5%AD%98%E5%99%A8%E5%88%B0RAM/5.png" alt=" "><br>参考来源：B站Ele实验室</p>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>数字电路</tag>
        <tag>RAM</tag>
      </tags>
  </entry>
  <entry>
    <title>直流电机</title>
    <url>/2024/05/21/%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="直流电机简介"><a href="#直流电机简介" class="headerlink" title="直流电机简介"></a>直流电机简介</h1><p>直流电机（Direct Current Motor）是一种将直流电能转换为机械能的电动机，广泛应用于各种需要精确控制速度和位置的机械系统中。直流电机因其调速范围广、启动性能好、控制简单等特点，在工业、家用电器、机器人等领域得到广泛应用。<br>直流电机的工作原理<br>直流电机的基本工作原理是利用电磁感应定律和电磁力相互作用。当直流电流通过电机的线圈（绕组）时，在线圈周围产生磁场，这个磁场与电机磁极的磁场相互作用，产生电磁力，推动电机转子旋转。<br><img src="/images/%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA/1.PNG" alt=" "></p>
<span id="more"></span>
<p><img src="/images/%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA/2.PNG" alt=" "></p>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><ol>
<li>定子（Stator）：</li>
</ol>
<ul>
<li>定子是直流电机的静止部分，通常包括磁极、机座和电刷装置。</li>
<li>磁极：定子中的磁极产生恒定磁场，通常由永磁体或电磁铁构成。</li>
</ul>
<ol start="2">
<li>转子（Rotor）：</li>
</ol>
<ul>
<li>转子是直流电机的旋转部分，通常包括绕组和换向器。</li>
<li>绕组：绕组是由导线绕成的线圈，当电流通过时产生电磁力。</li>
<li>换向器：换向器与电刷接触，负责改变绕组中的电流方向，确保转子连续旋转。</li>
</ul>
<ol start="3">
<li>电刷（Brush）：</li>
</ol>
<ul>
<li>电刷是与换向器接触的部分，通常由石墨制成，用于将电流传递给转子绕组。</li>
</ul>
<h1 id="直流电机的控制"><a href="#直流电机的控制" class="headerlink" title="直流电机的控制"></a>直流电机的控制</h1><p>直流电机的控制主要包括速度控制和位置控制两大方面。</p>
<ol>
<li>速度控制：</li>
</ol>
<ul>
<li>调压控制：通过改变电机输入电压来调节速度。</li>
<li>PWM控制（脉宽调制）：通过调节电机输入电压的占空比来控制速度，常用于电子控制器中。</li>
</ul>
<ol start="2">
<li>位置控制：</li>
</ol>
<ul>
<li>开环控制：不使用反馈信号，控制简单，适用于精度要求不高的场合。</li>
<li>闭环控制：使用反馈信号（如编码器信号）进行精确控制，适用于精度要求高的场合，如机器人、数控机床等。<br>PWM的思路就是利用定时器中断计数，划分一定的范围不供电，在高频下显出的效果就是电机转速的变化。<br><img src="/images/%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA/3.PNG" alt=" "></li>
</ul>
]]></content>
      <categories>
        <category>元件模块</category>
      </categories>
      <tags>
        <tag>电磁力</tag>
        <tag>脉宽调制</tag>
      </tags>
  </entry>
  <entry>
    <title>红外遥控</title>
    <url>/2024/05/21/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7/</url>
    <content><![CDATA[<p>简单来说，红外遥控的过程是红外发送LED发射红外光信号，红外接受LED接受信号，信号转化为高低电频之后需要满足一定的协议方可正常工作。</p>
<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>接收端红外二极管反向接入，红外光照射下电阻减小。未照射时输出高电平、照射时输出低电平。<br><img src="/images/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7/1.PNG" alt=" "></p>
<span id="more"></span>
<p>红外发射端发射的是高频脉冲（为了增强抗干扰能力），通过脉冲信号表示0、1以及起始和结束。<br><img src="/images/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7/2.PNG" alt=" "><br><img src="/images/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7/3.PNG" alt=" "><br><img src="/images/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7/4.PNG" alt=" "><br>红外信号的协议规定：起始码、地址码、地址反码（校验作用）、数据码、数据反码、（重复码）、结束码<br><img src="/images/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7/5.PNG" alt=" "><br><img src="/images/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7/6.PNG" alt=" "><br>不同设备可以用不同的地址码<br><img src="/images/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7/7.PNG" alt=" "><br>面对高频脉冲，处理并不容易，这里红外三极管，并加上一个专用芯片，将脉冲信号转化为数字信号。<br><img src="/images/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7/8.PNG" alt=" "><br><img src="/images/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7/9.PNG" alt=" "></p>
<h1 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h1><p>由于红外信号持续时间短，一旦接收到相关信号应该立即处理，这就是需要外部中断了。<br><img src="/images/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7/10.PNG" alt=" "><br>外部中断INT0, INT1接收信号，并选择通过哪种方式出发。EX0, EX1, EA使能，PX0设置优先级。</p>
]]></content>
      <categories>
        <category>元件模块</category>
      </categories>
      <tags>
        <tag>光敏电阻</tag>
        <tag>外部中断</tag>
      </tags>
  </entry>
  <entry>
    <title>蜂鸣器</title>
    <url>/2024/05/14/%E8%9C%82%E9%B8%A3%E5%99%A8/</url>
    <content><![CDATA[<p>蜂鸣器可以将电信号转化为声音信号。用于设备的按键音、报警音。<br><img src="/images/%E8%9C%82%E9%B8%A3%E5%99%A8/1.PNG" alt=" "></p>
<span id="more"></span>
<h1 id="蜂鸣器分类"><a href="#蜂鸣器分类" class="headerlink" title="蜂鸣器分类"></a>蜂鸣器分类</h1><p>按照驱动方式可以分为有源蜂鸣器和无源蜂鸣器。区别是内部是否带振荡源，带振荡源的只需要提供直流电压即可发声。</p>
<h1 id="驱动电路"><a href="#驱动电路" class="headerlink" title="驱动电路"></a>驱动电路</h1><p>蜂鸣器往往需要比微控制器引脚能提供的更高的电压，并且为了增强波形、提高设备可靠性和灵活性，驱动电路都必不可少。</p>
<h1 id="三极管驱动"><a href="#三极管驱动" class="headerlink" title="三极管驱动"></a>三极管驱动</h1><p>基极控制三极管导通、截止。VCC提供Buzzer需要的电压。<br><img src="/images/%E8%9C%82%E9%B8%A3%E5%99%A8/2.PNG" alt=" "></p>
<h1 id="集成电路驱动"><a href="#集成电路驱动" class="headerlink" title="集成电路驱动"></a>集成电路驱动</h1><p>ULN2023集成电路，适用于接受低电流信号并转化为能驱动较高电流负载的输出。<br><img src="/images/%E8%9C%82%E9%B8%A3%E5%99%A8/3.PNG" alt=" "></p>
<h1 id="单片机驱动蜂鸣器发声"><a href="#单片机驱动蜂鸣器发声" class="headerlink" title="单片机驱动蜂鸣器发声"></a>单片机驱动蜂鸣器发声</h1><p>通过I&#x2F;O口提供振荡信号，振荡信号的频率决定了蜂鸣器的音高，从而可以制作音乐。<br><img src="/images/%E8%9C%82%E9%B8%A3%E5%99%A8/4.PNG" alt=" "><br>参考来源：B站江科协51单片机教程</p>
]]></content>
      <categories>
        <category>元件模块</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>驱动电路</tag>
      </tags>
  </entry>
</search>
